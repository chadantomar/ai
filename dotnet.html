<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C# .NET / .NET Core - 50 Advanced Interview Questions | Chandan Kumar</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #0099cc;
            --neon-blue: #00d4ff;
            --dark-blue: #0a1929;
            --darker-blue: #051422;
        }
        body {
            font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Arial, sans-serif;
            background: var(--darker-blue);
            color: #e0e0e0;
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }
        .animated-bg {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: -1;
            background: var(--darker-blue);
            background-image: url('background-image.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: var(--darker-blue);
        }
        .animated-bg::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image:
                radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 153, 204, 0.1) 0%, transparent 50%);
            opacity: 0.6;
        }
        .animated-bg::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image:
                linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            opacity: 0.4;
        }
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(10, 25, 41, 0.85);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 212, 255, 0.2);
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            z-index: 1000;
            padding: 15px 0;
        }
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .back-btn {
            color: rgba(255, 255, 255, 0.9);
            text-decoration: none;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }
        .back-btn:hover {
            color: var(--neon-blue);
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.8);
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 120px 30px 60px;
        }
        .page-header {
            text-align: center;
            margin-bottom: 60px;
            padding: 40px 0;
        }
        .page-icon {
            font-size: 80px;
            margin-bottom: 30px;
            color: var(--neon-blue);
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
        }
        .page-title {
            font-size: 48px;
            font-weight: 800;
            margin-bottom: 20px;
            color: var(--neon-blue);
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }
        .page-subtitle {
            font-size: 20px;
            opacity: 0.9;
            color: #e0e0e0;
        }
        .question-card {
            background: rgba(10, 25, 41, 0.6);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        .question-number {
            color: var(--neon-blue);
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
        }
        .question-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--neon-blue);
            margin-bottom: 25px;
        }
        .question-section {
            margin-bottom: 30px;
        }
        .question-section h3 {
            font-size: 22px;
            color: var(--neon-blue);
            margin-bottom: 15px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
            padding-bottom: 10px;
        }
        .question-section p {
            font-size: 16px;
            line-height: 1.8;
            color: #e0e0e0;
            margin-bottom: 15px;
        }
        .question-section ul {
            list-style: none;
            padding-left: 0;
        }
        .question-section li {
            font-size: 16px;
            line-height: 1.8;
            margin-bottom: 12px;
            padding-left: 25px;
            position: relative;
            color: #e0e0e0;
        }
        .question-section li::before {
            content: 'â–¸';
            position: absolute;
            left: 0;
            color: var(--neon-blue);
            font-weight: bold;
        }
        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .pros-box, .cons-box {
            padding: 20px;
            border-radius: 10px;
        }
        .pros-box {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid rgba(0, 255, 0, 0.3);
        }
        .cons-box {
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid rgba(255, 0, 0, 0.3);
        }
        .pros-box h4 {
            color: #00ff00;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .cons-box h4 {
            color: #ff4444;
            margin-bottom: 15px;
            font-size: 18px;
        }
        .diagram-container {
            background: rgba(5, 20, 34, 0.8);
            border-radius: 15px;
            padding: 30px;
            margin: 25px 0;
            border: 2px solid rgba(0, 212, 255, 0.3);
        }
        .diagram-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--neon-blue);
            margin-bottom: 15px;
            text-align: center;
        }
        .mermaid {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
        }
        .mermaid svg {
            max-width: 100%;
            height: auto;
        }
        .mermaid .nodeLabel,
        .mermaid .edgeLabel,
        .mermaid .cluster-label text,
        .mermaid .label text,
        .mermaid text {
            fill: #000000 !important;
            color: #000000 !important;
        }
        .mermaid .node rect,
        .mermaid .node circle,
        .mermaid .node ellipse,
        .mermaid .cluster rect {
            fill: #ffffff;
            stroke: #333333;
        }
        .mermaid .edgePath .path {
            stroke: #333333;
        }
        .mermaid .arrowheadPath {
            fill: #333333;
        }
        .code-block {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid var(--neon-blue);
            overflow-x: auto;
        }
        .code-block pre {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .code-block code {
            color: #e0e0e0;
        }
        .highlight-box {
            background: rgba(0, 212, 255, 0.1);
            border-left: 4px solid var(--neon-blue);
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .toc {
            background: rgba(10, 25, 41, 0.6);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        .toc h2 {
            color: var(--neon-blue);
            margin-bottom: 20px;
        }
        .toc-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 10px;
        }
        .toc-list a {
            color: #e0e0e0;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 5px;
            transition: all 0.3s ease;
            display: block;
            font-size: 14px;
        }
        .toc-list a:hover {
            background: rgba(0, 212, 255, 0.2);
            color: var(--neon-blue);
        }
        @media (max-width: 768px) {
            .page-title { font-size: 32px; }
            .question-card { padding: 25px 20px; }
            .pros-cons { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="animated-bg"></div>
    <nav>
        <div class="nav-container">
            <div class="logo">Chandan Kumar</div>
            <a href="interview.html" class="back-btn">
                <i class="fas fa-arrow-left"></i> Back to Interview Guide
            </a>
        </div>
    </nav>

    <div class="container">
        <div class="page-header">
            <div class="page-icon"><i class="fas fa-code"></i></div>
            <h1 class="page-title">C# .NET / .NET Core</h1>
            <p class="page-subtitle">50 Advanced Interview Questions &amp; Answers</p>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-list" id="tocList"></div>
        </div>

        <!-- Questions Container -->
        <div id="questionsContainer"></div>
    </div>

    <script>
        const questions = [];

        // Q1 - Explain the difference between .NET Framework, .NET Core, and .NET 5+
        questions.push({
            number: 1,
            title: "Explain the difference between .NET Framework, .NET Core, and .NET 5+",
            description:
                ".NET Framework is Windows-only and effectively in maintenance mode. " +
                ".NET Core introduced cross-platform support, modular deployment, and a high-performance runtime. " +
                "Modern .NET (5 and later) unified .NET Core and .NET Framework into a single product line, with a common BCL, SDK-style projects, and a yearly release cadence.",
            why:
                "Understanding the evolution helps architects make decisions about migration, performance, cross-platform hosting, containerization, and long-term support. " +
                "Choosing the wrong runtime version directly impacts deployment options and maintenance.",
            what:
                ".NET Framework: Windows-only runtime, mature and stable, large ecosystem, being phased out. " +
                ".NET Core: Cross-platform (Windows, Linux, macOS), open-source, modular and lightweight, fast performance, side-by-side installation. " +
                ".NET 5+ (.NET 6, 7, 8): Unified platform, single .NET runtime, replaces both Framework and Core, modern and high-performance, long-term support versions. " +
                "Key Differences: Platform Support (Core/5+ are cross-platform, Framework is Windows-only), Performance (Core/5+ are faster and more efficient), " +
                "Deployment (Core/5+ support self-contained deployments), Package Management (Core/5+ use NuGet packages, Framework uses assemblies).",
            how:
                "For new greenfield apps, target the latest LTS (.NET 8 or later). " +
                "For brownfield apps, incrementally move libraries to .NET Standard / .NET, split monoliths into services, and modernize hosting with Kestrel and containers.",
            pros: [
                "Cross-platform (Windows, Linux, macOS, containers)",
                "Higher performance and lower memory footprint",
                "Unified SDK-style project system",
                "Regular release cadence and active improvements",
                "Better tooling and CLI support",
                "First-class container and cloud support"
            ],
            cons: [
                "Migration effort from legacy .NET Framework",
                "API gaps for very old or niche libraries",
                "Need to upgrade build and deployment pipelines",
                "New hosting concepts (Kestrel, generic host) to learn",
                "Some legacy tech (WebForms, WCF server) not directly supported"
            ],
            diagram: `flowchart TD
    A[".NET Framework<br/>Windows Only"] --> B[".NET Core<br/>Cross-platform"]
    B --> C[".NET 5+<br/>Unified Platform"]
    C --> D["Cloud-native Apps<br/>Containers & Kubernetes"]`,
            implementation: `// Modern .NET project file
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
</Project>

// Program.cs (minimal hosting)
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
var app = builder.Build();
app.MapControllers();
app.Run();`,
            approaches: [
                "New projects: start on latest LTS (.NET 8 or later).",
                "For legacy apps: use the strangler-fig pattern to carve out services.",
                "Use .NET Upgrade Assistant for guided migrations.",
                "Standardize solution templates across the organization.",
                "Align runtime versions with container base images and DevOps pipelines."
            ]
        });

        // Q2 - Explain .NET Core's dependency injection container
        questions.push({
            number: 2,
            title: "Explain .NET Core's dependency injection container",
            description:
                ".NET Core has built-in dependency injection with three main lifetimes: Singleton, Scoped, and Transient. " +
                "Services are registered in the container and injected into controllers, middleware, background services, and more via constructor injection.",
            why:
                "Proper DI usage reduces coupling, improves testability, and clarifies ownership of resources. " +
                "Incorrect lifetimes can cause memory leaks, concurrency bugs, and unexpected state sharing.",
            what:
                ".NET Core DI Container: Built-in dependency injection, service lifetime management, constructor injection by default. " +
                "Service Lifetimes: Singleton (one instance for application lifetime, shared across all requests, thread-safe required), " +
                "Scoped (one instance per request/scope, created per HTTP request, disposed at end of scope), " +
                "Transient (new instance every time, created each time requested, most lightweight).",
            how:
                "Register services in builder.Services. Inject them via constructor injection where needed. " +
                "Avoid the Service Locator pattern and make lifetimes explicit.",
            pros: [
                "Built-in and consistent DI story",
                "Supports constructor injection everywhere",
                "Clear lifetimes and ownership semantics",
                "Integration with configuration, logging, and options pattern"
            ],
            cons: [
                "Default container lacks some advanced features (interception, decorators) without extra code",
                "Misusing lifetimes can cause subtle bugs",
                "Circular dependencies can appear if design is not clean"
            ],
            diagram: `flowchart TD
    A["Service Collection"] --> B["Singleton Services"]
    A --> C["Scoped Services"]
    A --> D["Transient Services"]
    B --> E["Controllers and Handlers"]
    C --> E
    D --> E`,
            implementation: `// Startup.cs or Program.cs
builder.Services.AddSingleton<ICacheService, CacheService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddTransient<IEmailService, EmailService>();

// Usage
public class UserController : ControllerBase
{
    private readonly IUserService _userService;
    
    public UserController(IUserService userService)
    {
        _userService = userService; // Injected automatically
    }
}`,
            approaches: [
                "Use Scoped for domain and application services tied to a web request.",
                "Use Singleton only for stateless services or caches that are thread-safe.",
                "Use Transient for lightweight, short-lived services.",
                "Avoid capturing scoped services in singletons.",
                "Consider external DI containers only if advanced features are truly needed."
            ]
        });

        // Q3 - Explain .NET Core middleware pipeline
        questions.push({
            number: 3,
            title: "Explain .NET Core middleware pipeline",
            description:
                "ASP.NET Core uses a request-delegate pipeline composed of middleware components. " +
                "Each middleware can inspect, short-circuit, or modify the HTTP request and response, then call the next delegate. Ordering is critical.",
            why:
                "Understanding middleware is crucial for cross-cutting concerns like logging, metrics, correlation IDs, authentication, authorization, caching, and error handling.",
            what:
                "Middleware Pipeline: Request processing pipeline, components executed in order, each middleware can process request/response, can short-circuit pipeline.",
            how:
                "Implement a class with a constructor accepting RequestDelegate and an Invoke or InvokeAsync method. " +
                "Manipulate HttpContext before and after calling await _next(context). " +
                "Register it with app.UseMiddleware<T>().",
            pros: [
                "Clear separation of cross-cutting concerns",
                "Composable and testable pipeline",
                "Fine-grained control over request and response processing",
                "Good performance with minimal overhead",
                "Supports branching for custom routes"
            ],
            cons: [
                "Order-dependent and easy to misconfigure",
                "Coupled to HTTP abstractions",
                "Complex pipelines can be hard to debug",
                "Risk of swallowing exceptions if handled incorrectly"
            ],
            diagram: `flowchart LR
    A["Incoming Request"] --> B["Exception Handler"]
    B --> C["Routing"]
    C --> D["Authentication"]
    D --> E["Authorization"]
    E --> F["Custom Middleware"]
    F --> G["Endpoint Handler"]
    G --> H["Outgoing Response"]`,
            implementation: `public void Configure(IApplicationBuilder app)
{
    app.UseExceptionHandler(); // Error handling
    app.UseHttpsRedirection();
    app.UseStaticFiles();
    app.UseRouting();
    app.UseAuthentication();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
    });
}

// Custom Middleware
public class CustomMiddleware
{
    private readonly RequestDelegate _next;
    
    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        // Before next middleware
        await _next(context);
        // After next middleware
    }
}`,
            approaches: [
                "Put global exception handling and logging as the first middleware.",
                "Auth and authorization should run before business logic.",
                "Use MapWhen or UseWhen to branch the pipeline for specific paths.",
                "Keep middleware small and focused; avoid heavy domain logic inside it.",
                "Write integration tests using TestServer and HttpClient."
            ]
        });

        // Q4 - Explain C# async/await and Task-based programming
        questions.push({
            number: 4,
            title: "Explain C# async/await and Task-based programming",
            description:
                "Async/Await is the primary model for asynchronous programming in C#. " +
                "It enables non-blocking I/O operations and returns Task or Task<T>. " +
                "In ASP.NET Core, it is crucial for scalability and performance.",
            why:
                "High-throughput APIs rely on async I/O to scale. " +
                "Understanding async/await is essential for writing efficient, non-blocking code that can handle many concurrent requests.",
            what:
                "Async/Await: Asynchronous programming model, non-blocking I/O operations, returns Task or Task<T>. " +
                "Task vs Task<T>: Task represents async operation without return value, Task<T> represents async operation returning T. " +
                "Best Practices: Use async/await for I/O-bound operations, avoid async void (use async Task), ConfigureAwait(false) in libraries, use CancellationToken for cancellation.",
            how:
                "Mark methods with async keyword and return Task or Task<T>. " +
                "Use await to suspend execution until the awaited task completes. " +
                "Use async APIs for database, HTTP, file I/O, and messaging operations.",
            pros: [
                "Improved scalability via non-blocking I/O",
                "Simpler code compared to callbacks or manual tasks",
                "Better CPU utilization under load",
                "Type-safe async operations"
            ],
            cons: [
                "Learning curve for async flow and error handling",
                "Potential for fire-and-forget bugs",
                "Unobserved exceptions if tasks are not awaited",
                "Can complicate debugging stack traces"
            ],
            diagram: `flowchart TD
    A["HTTP Request"] --> B["Async Controller"]
    B --> C["Async DB Call"]
    C -->|"I/O Pending"| D["Thread to Pool"]
    D --> E["Serve Other Requests"]
    C -->|"Completed"| F["Continuation"]
    F --> G["Build Response"]
    G --> H["Send Response"]`,
            implementation: `public async Task<string> GetDataAsync()
{
    using var client = new HttpClient();
    var response = await client.GetStringAsync("https://api.example.com/data");
    return response;
}

// Usage
var data = await GetDataAsync();

// Task vs Task<T>
Task task = DoSomethingAsync(); // No return value
Task<string> taskWithResult = GetDataAsync(); // Returns string

// Best Practices
public async Task ProcessAsync(CancellationToken cancellationToken)
{
    await Task.Delay(1000, cancellationToken);
}`,
            approaches: [
                "Make the entire call chain async all the way down.",
                "Never block on async code in web apps.",
                "Use async APIs for DB, HTTP, IO, and messaging.",
                "Log and handle Task cancellations gracefully.",
                "Apply ConfigureAwait(false) in class libraries where resume on context is not required."
            ]
        });

        // Q5
        questions.push({
            number: 5,
            title: "Describe async and await in C# and common pitfalls in ASP.NET Core.",
            description:
                "async and await is the primary model for asynchronous programming in C#. " +
                "In ASP.NET Core, it is crucial for non-blocking I/O and scalability. " +
                "However, improper use can cause thread pool starvation and performance issues.",
            why:
                "High-throughput APIs rely on async I/O to scale. " +
                "Blocking calls using Task.Result or .Wait() can reduce concurrency and cause timeouts under load.",
            what:
                "An async method returns Task or Task<T>. The await keyword suspends the method until the awaited task completes, " +
                "freeing the thread to serve other requests. ASP.NET Core does not use the legacy SynchronizationContext, reducing deadlock issues.",
            how:
                "Mark controller actions async and use asynchronous I/O APIs (EF Core async methods, HttpClient async APIs, etc.). " +
                "Avoid blocking on tasks and use ConfigureAwait(false) appropriately in libraries.",
            pros: [
                "Improved scalability via non-blocking I/O",
                "Simpler code compared to callbacks or manual tasks",
                "Better CPU utilization under load"
            ],
            cons: [
                "Learning curve for async flow and error handling",
                "Potential for fire-and-forget bugs",
                "Unobserved exceptions if tasks are not awaited",
                "Can complicate debugging stack traces"
            ],
            diagram: `flowchart TD
    A["Incoming HTTP Request"] --> B["Controller Action async"]
    B --> C["Database Async Call"]
    C -->|"I/O Pending"| D["Thread Returned to Pool"]
    D --> E["Serves Other Requests"]
    C -->|"Completed"| F["Continuation"]
    F --> G["Build Response"]
    G --> H["Send Response"]`,
            implementation: `// Good: fully async controller
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly AppDbContext _db;

    public ProductsController(AppDbContext db) => _db = db;

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> Get()
    {
        var products = await _db.Products
            .AsNoTracking()
            .ToListAsync();

        return Ok(products);
    }
}

// Bad: blocking on async
public IActionResult GetSync()
{
    // This can cause thread-pool starvation
    var products = _db.Products.ToListAsync().Result;
    return Ok(products);
}`,
            approaches: [
                "Make the entire call chain async all the way down.",
                "Never block on async code in web apps.",
                "Use async APIs for DB, HTTP, IO, and messaging.",
                "Log and handle Task cancellations gracefully.",
                "Apply ConfigureAwait(false) in class libraries where resume on context is not required."
            ]
        });

        // Q6
        questions.push({
            number: 6,
            title: "How does Entity Framework Core tracking versus AsNoTracking impact performance and behavior?",
            description:
                "EF Core change tracking keeps an in-memory graph of entities to detect modifications on SaveChanges. " +
                "AsNoTracking queries skip this to reduce overhead. The choice affects performance, memory, and behavior.",
            why:
                "In read-heavy APIs, unnecessary tracking can severely impact performance. " +
                "In write scenarios, tracking is useful for automatic change detection and concurrency control.",
            what:
                "Tracked queries keep entity instances in the DbContext ChangeTracker. " +
                "AsNoTracking queries materialize objects but do not track them, making them ideal for read-only queries and projections.",
            how:
                "Use AsNoTracking on read-only queries. Keep DbContext scope short (per request). " +
                "Use explicit Attach or Update for detached entities when needed.",
            pros: [
                "Tracking: automatic change detection and concurrency features",
                "AsNoTracking: reduced memory and CPU usage",
                "Better scalability for read-only endpoints"
            ],
            cons: [
                "Tracking: overhead in high-volume read queries",
                "AsNoTracking: manual merge logic for updates",
                "Misuse can cause unexpected overwrites or missing updates"
            ],
            diagram: `flowchart TD
    A[DbContext] --> B[Tracked Query]
    B --> C[Change Tracker]
    A --> D[AsNoTracking Query]
    D --> E[Objects Without Tracking]`,
            implementation: `// Tracked: default
var customer = await _db.Customers.FirstAsync(c => c.Id == id);
customer.Name = "Updated Name";
await _db.SaveChangesAsync(); // EF detects changes

// Read-only: use AsNoTracking
var customers = await _db.Customers
    .AsNoTracking()
    .Where(c => c.IsActive)
    .ToListAsync();

// Global convention
builder.Services.AddDbContext<AppDbContext>(options =>
{
    options.UseSqlServer(connString);
    options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
});`,
            approaches: [
                "Use AsNoTracking for all read-only endpoints by default.",
                "Limit DbContext lifetime to a single request.",
                "Avoid long-lived DbContexts with many tracked entities.",
                "For updates from detached DTOs, map to entity and attach with correct state.",
                "Profile queries and tracking behavior using logging and metrics."
            ]
        });

        // Q7
        questions.push({
            number: 7,
            title: "How do you implement global exception handling and ProblemDetails in ASP.NET Core APIs?",
            description:
                "Global exception handling centralizes error handling and ensures consistent response formats. " +
                "ProblemDetails (RFC 7807) is the recommended standard for HTTP error responses in JSON APIs.",
            why:
                "Without a central error handler, exceptions can leak stack traces, produce inconsistent responses, " +
                "and make observability harder. ProblemDetails simplifies client handling and documentation.",
            what:
                "A top-level middleware (or UseExceptionHandler) catches all unhandled exceptions, logs them, " +
                "and returns a ProblemDetails JSON payload with traceId, status, title, and detail.",
            how:
                "Create a custom middleware or use app.UseExceptionHandler. Map exceptions to HTTP status codes. " +
                "Return TypedResults.Problem or ProblemDetails objects from minimal APIs when appropriate.",
            pros: [
                "Consistent error schema across endpoints",
                "Centralized logging and correlation",
                "Easier client-side error handling",
                "Better security by avoiding raw stack traces"
            ],
            cons: [
                "Need to maintain mapping of domain exceptions to HTTP codes",
                "Complex business errors may require custom extensions",
                "Requires discipline so controllers do not override global behavior"
            ],
            diagram: `flowchart TD
    A[Incoming Request] --> B[Global Exception Middleware]
    B --> C[Controller or Endpoint]
    C -->|Throws Exception| B
    B --> D[Log and Map to ProblemDetails]
    D --> E[JSON Error Response]`,
            implementation: `// Global exception middleware example
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionMiddleware> _logger;

    public GlobalExceptionMiddleware(RequestDelegate next,
                                     ILogger<GlobalExceptionMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (DomainException dex)
        {
            _logger.LogWarning(dex, "Domain error");
            await WriteProblem(context, StatusCodes.Status400BadRequest, dex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled error");
            await WriteProblem(context, StatusCodes.Status500InternalServerError,
                "An unexpected error occurred.");
        }
    }

    private static async Task WriteProblem(HttpContext ctx, int status, string detail)
    {
        ctx.Response.StatusCode = status;
        ctx.Response.ContentType = "application/problem+json";

        var problem = new ProblemDetails
        {
            Status = status,
            Title = ReasonPhrases.GetReasonPhrase(status),
            Detail = detail,
            Instance = ctx.Request.Path
        };

        problem.Extensions["traceId"] = ctx.TraceIdentifier;

        await ctx.Response.WriteAsJsonAsync(problem);
    }
}

// Registration
var app = builder.Build();
app.UseMiddleware<GlobalExceptionMiddleware>();`,
            approaches: [
                "Use a single global middleware for exception handling.",
                "Map domain-level exceptions to 4xx codes and technical ones to 5xx.",
                "Always include traceId or correlationId for troubleshooting.",
                "Align response schema with OpenAPI or Swagger documentation.",
                "Avoid duplicating error logic inside controllers."
            ]
        });

        // Q8
        questions.push({
            number: 8,
            title: "What is HttpClientFactory and how does it solve common HttpClient issues?",
            description:
                "HttpClientFactory centralizes creation and lifetime management of HttpClient instances. " +
                "It avoids socket exhaustion, allows named and typed clients, and integrates with resilience libraries like Polly.",
            why:
                "Incorrect use of HttpClient (creating a new instance per request or using a single static without proper policies) " +
                "can cause socket exhaustion or missing resilience features.",
            what:
                "IHttpClientFactory creates HttpClient instances with managed handlers. " +
                "You can configure named clients, typed clients, and delegating handlers for logging and retries.",
            how:
                "Register services.AddHttpClient(), then inject HttpClient via typed client or factory. " +
                "Configure base addresses, default headers, and policies during registration.",
            pros: [
                "Prevents socket exhaustion",
                "Centralized configuration for outbound calls",
                "Supports resilience policies and delegating handlers",
                "Improves testability via typed clients"
            ],
            cons: [
                "Extra abstraction to learn",
                "Misconfigured handlers can still cause issues",
                "Retry policies must be carefully designed to avoid overload"
            ],
            diagram: `flowchart TD
    A[Service Collection] --> B[AddHttpClient]
    B --> C[IHttpClientFactory]
    C --> D[Named Client]
    C --> E[Typed Client]
    D --> F[External API]
    E --> F`,
            implementation: `// Program.cs
builder.Services.AddHttpClient("GitHub", client =>
{
    client.BaseAddress = new Uri("https://api.github.com/");
    client.DefaultRequestHeaders.UserAgent.ParseAdd("MyApp");
});

// Typed client
public class GitHubClient
{
    private readonly HttpClient _http;

    public GitHubClient(HttpClient http)
    {
        _http = http;
    }

    public Task<string> GetUserAsync(string user)
        => _http.GetStringAsync($"/users/{user}");
}

builder.Services.AddHttpClient<GitHubClient>(client =>
{
    client.BaseAddress = new Uri("https://api.github.com/");
});

// Usage
public class MyService
{
    private readonly GitHubClient _client;

    public MyService(GitHubClient client) => _client = client;

    public Task<string> GetUser(string user) => _client.GetUserAsync(user);
}`,
            approaches: [
                "Prefer typed clients for domain-specific outbound integrations.",
                "Use named clients when you need different configurations for the same host.",
                "Attach logging and metrics handlers for observability.",
                "Integrate Polly for retries, circuit breakers, and timeouts.",
                "Avoid manually managing static HttpClient instances in ASP.NET Core."
            ]
        });

        // Q9
        questions.push({
            number: 9,
            title: "Minimal APIs vs traditional controllers: when and why would you choose one over the other?",
            description:
                "Minimal APIs provide a lightweight way to define HTTP endpoints using top-level statements. " +
                "They are great for small services, prototypes, and focused APIs. Controllers provide more structure, discoverability, filters, and conventions.",
            why:
                "Architecture decisions here affect maintainability, testability, and how large teams collaborate. Using both styles without guidance can confuse the team.",
            what:
                "Minimal APIs use MapGet and MapPost style endpoints. Controllers are classes inheriting from ControllerBase, using routing attributes and conventions.",
            how:
                "For simple CRUD or gateway endpoints, use minimal APIs. For complex domains with filters, versioning, and attributes, controllers are often more expressive.",
            pros: [
                "Minimal APIs: less ceremony and fewer files",
                "Fast to spin up for microservices or internal tools",
                "Controllers: rich attribute model, filters, versioning, and conventions",
                "Better separation for large teams and big domains"
            ],
            cons: [
                "Minimal APIs: can become messy for large domains if not structured",
                "Controllers: more boilerplate for simple endpoints",
                "Mixing styles without guidelines can confuse the team"
            ],
            diagram: `flowchart TD
    A[Program.cs] --> B[Minimal API Endpoint]
    A --> C[Controller Route]
    B --> D[Handler Function]
    C --> E[Controller Action]`,
            implementation: `// Minimal API
var app = builder.Build();

app.MapGet("/health", () => Results.Ok(new { status = "Healthy" }));

app.MapPost("/orders", async (CreateOrderDto dto, IOrderService service) =>
{
    var result = await service.CreateAsync(dto);
    return Results.Created($"/orders/{result.Id}", result);
});

// Traditional controller
[ApiController]
[Route("api/[controller]")]
public class OrdersController : ControllerBase
{
    private readonly IOrderService _service;
    public OrdersController(IOrderService service) => _service = service;

    [HttpPost]
    public async Task<IActionResult> Create(CreateOrderDto dto)
    {
        var result = await _service.CreateAsync(dto);
        return CreatedAtAction(nameof(GetById), new { id = result.Id }, result);
    }

    [HttpGet("{id}")]
    public Task<OrderDto> GetById(Guid id) => _service.GetByIdAsync(id);
}`,
            approaches: [
                "Use minimal APIs for small services or edge gateways.",
                "Use controllers for complex domains and heavy use of filters and versioning.",
                "Impose folder and namespace conventions for minimal APIs to avoid a huge Program.cs.",
                "Share application and domain layers between both styles.",
                "Document the chosen approach in architecture decision records."
            ]
        });

        // Q10
        questions.push({
            number: 10,
            title: "How do you host background jobs using IHostedService or BackgroundService in .NET Core?",
            description:
                "Background services run alongside your web application within the same process, using IHostedService or BackgroundService. " +
                "They are useful for polling, scheduled work, or long-running processes that do not directly handle HTTP.",
            why:
                "Many systems need background tasks such as sending emails, syncing data, or running sagas. " +
                "Hosting them incorrectly can lead to resource leaks or unreliable execution.",
            what:
                "IHostedService defines StartAsync and StopAsync. BackgroundService provides a base class with an ExecuteAsync loop. " +
                "They are hosted by the generic host.",
            how:
                "Implement BackgroundService, inject dependencies, and register via AddHostedService<T>(). " +
                "Respect cancellation tokens and avoid blocking calls.",
            pros: [
                "Simple hosting model tied to application lifecycle",
                "No external scheduler needed for simple tasks",
                "Full access to DI container and configuration"
            ],
            cons: [
                "Sharing resources with the web app may cause contention",
                "If the web app restarts, background jobs restart too",
                "Not ideal for heavy or mission-critical long-running jobs"
            ],
            diagram: `flowchart TD
    A[Web Host] --> B[ASP.NET Core Pipeline]
    A --> C[BackgroundService 1]
    A --> D[BackgroundService 2]
    C --> E[Periodic Work]
    D --> F[Queue Listener]`,
            implementation: `public class EmailBackgroundService : BackgroundService
{
    private readonly ILogger<EmailBackgroundService> _logger;
    private readonly IEmailQueue _queue;

    public EmailBackgroundService(ILogger<EmailBackgroundService> logger,
                                  IEmailQueue queue)
    {
        _logger = logger;
        _queue = queue;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Email background service started");
        while (!stoppingToken.IsCancellationRequested)
        {
            var email = await _queue.DequeueAsync(stoppingToken);
            if (email is null)
            {
                await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
                continue;
            }

            try
            {
                await SendEmailAsync(email, stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error sending email");
            }
        }
    }
}

// Registration
builder.Services.AddHostedService<EmailBackgroundService>();`,
            approaches: [
                "Use BackgroundService for lightweight periodic tasks or queue listeners.",
                "For heavy workloads, host separate worker services or containerized jobs.",
                "Always respect CancellationToken and handle graceful shutdown.",
                "Use health checks and readiness probes if background tasks affect availability.",
                "Combine with queues for resilient processing."
            ]
        });

        // Q11
        questions.push({
            number: 11,
            title: "Explain health checks in ASP.NET Core and how you design them for microservices.",
            description:
                "Health checks provide liveness and readiness endpoints that reflect the state of the application and its dependencies " +
                "(databases, caches, message brokers, etc.). They integrate well with Kubernetes, load balancers, and monitoring systems.",
            why:
                "Correct health checks prevent sending traffic to unhealthy instances and improve reliability and self-healing in orchestrated environments.",
            what:
                "ASP.NET Core offers health check libraries. You register checks and expose endpoints such as /health/live and /health/ready.",
            how:
                "Use services.AddHealthChecks().AddSqlServer(...).AddRedis(...); and map endpoints with app.MapHealthChecks.",
            pros: [
                "Simple integration with Kubernetes and reverse proxies",
                "Pluggable checks for common dependencies",
                "Custom checks for domain-specific conditions"
            ],
            cons: [
                "If checks are too heavy, they can add load or timeouts",
                "Poorly designed checks may cause cascading failures",
                "Requires coordination with DevOps for thresholds and probes"
            ],
            diagram: `flowchart TD
    A["Service Instance"] --> B["/health/live"]
    A --> C["/health/ready"]
    B --> D["Kubernetes Liveness Probe"]
    C --> E["Load Balancer Readiness Probe"]`,
            implementation: `// Program.cs
builder.Services.AddHealthChecks()
    .AddSqlServer(builder.Configuration.GetConnectionString("Default"))
    .AddRedis("localhost:6379", name: "redis");

// Basic endpoints
var app = builder.Build();
app.MapHealthChecks("/health/live");
app.MapHealthChecks("/health/ready");`,
            approaches: [
                "Separate liveness (is process running) from readiness (can serve traffic).",
                "Mark expensive external checks as readiness only.",
                "Use tags to filter checks per endpoint when needed.",
                "Align intervals and timeouts with the hosting platform.",
                "Include simple domain health signals where relevant."
            ]
        });

        // Q12
        questions.push({
            number: 12,
            title: "How do you implement API versioning and deprecation strategies in ASP.NET Core?",
            description:
                "API versioning allows you to evolve contracts without breaking existing clients. " +
                "ASP.NET Core can support URL, header, or query string versioning, often using the official versioning package.",
            why:
                "Large systems cannot break clients suddenly. You need clear strategies for introducing new versions, maintaining older ones, and eventually deprecating them.",
            what:
                "You define versions (v1, v2, etc.) and map controllers or endpoints to them. Versioning metadata appears in Swagger and may be communicated via headers or paths.",
            how:
                "Use AddApiVersioning, decorate controllers with ApiVersion, and route via api/v{version:apiVersion}/[controller]. Expose deprecation via headers and documentation.",
            pros: [
                "Controlled evolution of API surface",
                "Backward compatibility for existing consumers",
                "Ability to sunset old versions with clear timelines"
            ],
            cons: [
                "More endpoints to maintain and test",
                "Risk of version explosion if not governed",
                "Need strong communication with consumers"
            ],
            diagram: `flowchart TD
    A["Client v1"] --> B["/api/v1/orders"]
    A --> C["/api/v1/customers"]
    D["Client v2"] --> E["/api/v2/orders"]
    E --> F["New Contract or Behavior"]`,
            implementation: `// Program.cs
builder.Services.AddApiVersioning(options =>
{
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.ReportApiVersions = true;
});

// Controller v1
[ApiController]
[ApiVersion("1.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class OrdersController : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetV1(int id) => Ok(new { Version = "v1", Id = id });
}

// Controller v2
[ApiController]
[ApiVersion("2.0")]
[Route("api/v{version:apiVersion}/[controller]")]
public class OrdersV2Controller : ControllerBase
{
    [HttpGet("{id}")]
    public IActionResult GetV2(int id) => Ok(new { Version = "v2", Id = id, Extra = "..." });
}`,
            approaches: [
                "Prefer URL versioning for public REST APIs.",
                "Keep versions minimal and only when breaking changes are required.",
                "Communicate deprecation via headers and documentation.",
                "Automate tests across all active API versions.",
                "Maintain architecture decision records describing versioning strategy."
            ]
        });

        // Q13 - Explain the difference between .NET Framework, .NET Core, and .NET 5+
        questions.push({
            number: 13,
            title: "Explain the difference between .NET Framework, .NET Core, and .NET 5+",
            description:
                ".NET Framework is Windows-only and effectively in maintenance mode. " +
                ".NET Core introduced cross-platform support, modular deployment, and a high-performance runtime. " +
                "Modern .NET (5 and later) unified .NET Core and .NET Framework into a single product line, with a common BCL, SDK-style projects, and a yearly release cadence.",
            why:
                "Understanding the evolution helps architects make decisions about migration, performance, cross-platform hosting, containerization, and long-term support. " +
                "Choosing the wrong runtime version directly impacts deployment options and maintenance.",
            what:
                ".NET Framework: Windows-only runtime, mature and stable, large ecosystem, being phased out. " +
                ".NET Core: Cross-platform (Windows, Linux, macOS), open-source, modular and lightweight, fast performance, side-by-side installation. " +
                ".NET 5+: Unified platform, single .NET runtime, replaces both Framework and Core, modern and high-performance, long-term support versions.",
            how:
                "For new greenfield apps, target the latest LTS (.NET 8 or later). " +
                "For brownfield apps, incrementally move libraries to .NET Standard / .NET, split monoliths into services, and modernize hosting with Kestrel and containers.",
            pros: [
                "Cross-platform (Windows, Linux, macOS, containers)",
                "Higher performance and lower memory footprint",
                "Unified SDK-style project system",
                "Regular release cadence and active improvements",
                "Better tooling and CLI support",
                "First-class container and cloud support"
            ],
            cons: [
                "Migration effort from legacy .NET Framework",
                "API gaps for very old or niche libraries",
                "Need to upgrade build and deployment pipelines",
                "New hosting concepts (Kestrel, generic host) to learn",
                "Some legacy tech (WebForms, WCF server) not directly supported"
            ],
            diagram: `flowchart TD
    A[.NET Framework<br/>Windows Only] --> B[.NET Core<br/>Cross-platform]
    B --> C[.NET 5+<br/>Unified Platform]
    C --> D[Cloud-native Apps<br/>Containers & Kubernetes]`,
            implementation: `// Modern .NET project file
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>
</Project>

// Program.cs (minimal hosting)
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
var app = builder.Build();
app.MapControllers();
app.Run();`,
            approaches: [
                "New projects: start on latest LTS (.NET 8 or later).",
                "For legacy apps: use the strangler-fig pattern to carve out services.",
                "Use .NET Upgrade Assistant for guided migrations.",
                "Standardize solution templates across the organization.",
                "Align runtime versions with container base images and DevOps pipelines."
            ]
        });

        // Q14 - Explain .NET Core's dependency injection container
        questions.push({
            number: 14,
            title: "Explain .NET Core's dependency injection container and service lifetimes",
            description:
                ".NET Core has built-in dependency injection with three main lifetimes: Singleton, Scoped, and Transient. " +
                "Services are registered in the container and injected into controllers, middleware, background services, and more via constructor injection.",
            why:
                "Proper DI usage reduces coupling, improves testability, and clarifies ownership of resources. " +
                "Incorrect lifetimes can cause memory leaks, concurrency bugs, and unexpected state sharing.",
            what:
                "Singleton: one instance for the entire application lifetime, shared across all requests, thread-safe required. " +
                "Scoped: one instance per request or logical scope, created per HTTP request, disposed at end of scope. " +
                "Transient: new instance every time it is requested, created each time requested, most lightweight.",
            how:
                "Register services in builder.Services. Inject them via constructor injection where needed. " +
                "Avoid the Service Locator pattern and make lifetimes explicit.",
            pros: [
                "Built-in and consistent DI story",
                "Supports constructor injection everywhere",
                "Clear lifetimes and ownership semantics",
                "Integration with configuration, logging, and options pattern"
            ],
            cons: [
                "Default container lacks some advanced features (interception, decorators) without extra code",
                "Misusing lifetimes can cause subtle bugs",
                "Circular dependencies can appear if design is not clean"
            ],
            diagram: `flowchart TD
    A[Service Collection] --> B[Singleton Services]
    A --> C[Scoped Services]
    A --> D[Transient Services]
    B --> E[Controllers & Handlers]
    C --> E
    D --> E`,
            implementation: `// Program.cs - service registrations
builder.Services.AddSingleton<ICacheService, CacheService>();
builder.Services.AddScoped<IUserService, UserService>();
builder.Services.AddTransient<IEmailService, EmailService>();

// Usage
public class UserController : ControllerBase
{
    private readonly IUserService _userService;
    
    public UserController(IUserService userService)
    {
        _userService = userService; // Injected automatically
    }
}`,
            approaches: [
                "Use Scoped for domain and application services tied to a web request.",
                "Use Singleton only for stateless services or caches that are thread-safe.",
                "Use Transient for lightweight, short-lived services.",
                "Avoid capturing scoped services in singletons.",
                "Consider external DI containers only if advanced features are truly needed."
            ]
        });

        // Q15 - Explain .NET Core middleware pipeline
        questions.push({
            number: 15,
            title: "Explain .NET Core middleware pipeline and custom middleware",
            description:
                "ASP.NET Core uses a request-delegate pipeline composed of middleware components. " +
                "Each middleware can inspect, short-circuit, or modify the HTTP request and response, then call the next delegate. Ordering is critical.",
            why:
                "Understanding middleware is crucial for cross-cutting concerns like logging, metrics, correlation IDs, authentication, authorization, caching, and error handling.",
            what:
                "Middleware is a function or class that receives HttpContext and a 'next' delegate. " +
                "You register middleware in Program.cs using methods like Use, UseWhen, and Map.",
            how:
                "Implement a class with a constructor accepting RequestDelegate and an Invoke or InvokeAsync method. " +
                "Manipulate HttpContext before and after calling await _next(context). " +
                "Register it with app.UseMiddleware<T>().",
            pros: [
                "Clear separation of cross-cutting concerns",
                "Composable and testable pipeline",
                "Fine-grained control over request and response processing",
                "Good performance with minimal overhead",
                "Supports branching for custom routes"
            ],
            cons: [
                "Order-dependent and easy to misconfigure",
                "Coupled to HTTP abstractions",
                "Complex pipelines can be hard to debug",
                "Risk of swallowing exceptions if handled incorrectly"
            ],
            diagram: `flowchart LR
    A[Incoming Request] --> B[Exception Handler]
    B --> C[Routing]
    C --> D[Authentication]
    D --> E[Authorization]
    E --> F[Custom Middleware]
    F --> G[Endpoint Handler]
    G --> H[Outgoing Response]`,
            implementation: `// Custom middleware example
public class RequestTimingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestTimingMiddleware> _logger;

    public RequestTimingMiddleware(RequestDelegate next,
                                   ILogger<RequestTimingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var sw = Stopwatch.StartNew();
        try
        {
            await _next(context);
        }
        finally
        {
            sw.Stop();
            _logger.LogInformation("Request {Path} took {Elapsed} ms",
                context.Request.Path, sw.ElapsedMilliseconds);
        }
    }
}

// Registration in Program.cs
var app = builder.Build();
app.UseMiddleware<RequestTimingMiddleware>();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.Run();`,
            approaches: [
                "Put global exception handling and logging as the first middleware.",
                "Auth and authorization should run before business logic.",
                "Use MapWhen or UseWhen to branch the pipeline for specific paths.",
                "Keep middleware small and focused; avoid heavy domain logic inside it.",
                "Write integration tests using TestServer and HttpClient."
            ]
        });

        // Q16 - Explain C# async/await and Task-based programming
        questions.push({
            number: 16,
            title: "Explain C# async/await and Task-based programming",
            description:
                "async and await is the primary model for asynchronous programming in C#. " +
                "In ASP.NET Core, it is crucial for non-blocking I/O and scalability. " +
                "However, improper use can cause thread pool starvation and performance issues.",
            why:
                "High-throughput APIs rely on async I/O to scale. " +
                "Blocking calls using Task.Result or .Wait() can reduce concurrency and cause timeouts under load.",
            what:
                "An async method returns Task or Task<T>. The await keyword suspends the method until the awaited task completes, " +
                "freeing the thread to serve other requests. ASP.NET Core does not use the legacy SynchronizationContext, reducing deadlock issues.",
            how:
                "Mark controller actions async and use asynchronous I/O APIs (EF Core async methods, HttpClient async APIs, etc.). " +
                "Avoid blocking on tasks and use ConfigureAwait(false) appropriately in libraries.",
            pros: [
                "Improved scalability via non-blocking I/O",
                "Simpler code compared to callbacks or manual tasks",
                "Better CPU utilization under load"
            ],
            cons: [
                "Learning curve for async flow and error handling",
                "Potential for fire-and-forget bugs",
                "Unobserved exceptions if tasks are not awaited",
                "Can complicate debugging stack traces"
            ],
            diagram: `flowchart TD
    A[HTTP Request] --> B[Async Controller]
    B --> C[Async DB Call]
    C -->|I/O Pending| D[Thread to Pool]
    D --> E[Serve Other Requests]
    C -->|Completed| F[Continuation]
    F --> G[Build Response]
    G --> H[Send Response]`,
            implementation: `// Good: fully async controller
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly AppDbContext _db;

    public ProductsController(AppDbContext db) => _db = db;

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> Get()
    {
        var products = await _db.Products
            .AsNoTracking()
            .ToListAsync();
        return Ok(products);
    }
}

// Bad: blocking on async
public IActionResult GetSync()
{
    // This can cause thread-pool starvation
    var products = _db.Products.ToListAsync().Result;
    return Ok(products);
}`,
            approaches: [
                "Make the entire call chain async all the way down.",
                "Never block on async code in web apps.",
                "Use async APIs for DB, HTTP, IO, and messaging.",
                "Log and handle Task cancellations gracefully.",
                "Apply ConfigureAwait(false) in class libraries where resume on context is not required."
            ]
        });

        // Q17 - Explain LINQ and its query syntax vs method syntax
        questions.push({
            number: 17,
            title: "Explain LINQ and its query syntax vs method syntax",
            description:
                "LINQ (Language Integrated Query) provides a unified way to query data from various sources. " +
                "It supports both query syntax (SQL-like) and method syntax (fluent API). " +
                "LINQ uses deferred execution, meaning queries are not executed until enumerated.",
            why:
                "LINQ is fundamental to C# development and enables functional programming patterns. " +
                "Understanding deferred execution is crucial for performance and memory efficiency.",
            what:
                "Query Syntax: SQL-like syntax using from, where, orderby, select keywords. " +
                "Method Syntax: Fluent API using extension methods like Where, OrderBy, Select. " +
                "Deferred Execution: Query not executed until enumerated (ToList, ToArray, foreach).",
            how:
                "Use query syntax for complex joins and grouping. " +
                "Use method syntax for simple filtering and transformations. " +
                "Materialize queries with ToList() or ToArray() when you need the results immediately.",
            pros: [
                "Unified query syntax for different data sources",
                "Type-safe queries with IntelliSense support",
                "Deferred execution for efficient memory usage",
                "Composable and chainable operations"
            ],
            cons: [
                "Learning curve for complex queries",
                "Potential performance issues if not used correctly",
                "N+1 query problem if not careful with navigation properties"
            ],
            diagram: `flowchart TD
    A[Data Source] --> B[LINQ Query]
    B --> C[Query Syntax]
    B --> D[Method Syntax]
    C --> E[Deferred Execution]
    D --> E
    E --> F[Materialization]
    F --> G[Results]`,
            implementation: `// Query Syntax
var result = from user in users
             where user.Age > 18
             orderby user.Name
             select user.Name;

// Method Syntax
var result = users
    .Where(user => user.Age > 18)
    .OrderBy(user => user.Name)
    .Select(user => user.Name);

// Deferred Execution
var query = users.Where(u => u.IsActive); // Not executed yet
var list = query.ToList(); // Now executed

// Immediate Execution
var count = users.Count(); // Executed immediately`,
            approaches: [
                "Use query syntax for complex joins and grouping.",
                "Use method syntax for simple filtering and transformations.",
                "Materialize queries with ToList() or ToArray() when needed.",
                "Be aware of deferred execution to avoid multiple enumerations.",
                "Use AsQueryable() for database queries to translate to SQL."
            ]
        });

        // Q18 - Explain C# generics and constraints
        questions.push({
            number: 18,
            title: "Explain C# generics and constraints",
            description:
                "Generics enable type-safe code reuse by allowing classes, methods, and interfaces to work with any data type. " +
                "Constraints restrict the types that can be used as type arguments, ensuring type safety and enabling specific operations.",
            why:
                "Generics provide type safety at compile-time, eliminate boxing/unboxing overhead, and enable code reuse without sacrificing type safety.",
            what:
                "Generics allow you to define type parameters that are specified when the generic type is used. " +
                "Constraints (where T : class, where T : struct, where T : new(), where T : IComparable) restrict what types can be used.",
            how:
                "Define generic types with type parameters: class Repository<T>. " +
                "Add constraints: where T : class, where T : IComparable. " +
                "Use generic types: var repo = new Repository<User>();",
            pros: [
                "Type-safe code reuse",
                "Compile-time type checking",
                "Performance benefits (no boxing)",
                "IntelliSense support"
            ],
            cons: [
                "Can make code more complex",
                "Learning curve for advanced scenarios",
                "Some constraints can be restrictive"
            ],
            diagram: `flowchart TD
    A[Generic Type Definition] --> B[Type Parameter T]
    B --> C[Constraints]
    C --> D[where T : class]
    C --> E[where T : struct]
    C --> F[where T : IComparable]
    D --> G[Concrete Type Usage]
    E --> G
    F --> G`,
            implementation: `// Generic class with constraints
public class Repository<T> where T : class
{
    private List<T> _items = new List<T>();
    
    public void Add(T item)
    {
        _items.Add(item);
    }
    
    public T GetById(int id)
    {
        return _items.FirstOrDefault();
    }
}

// Generic method
public static T Max<T>(T a, T b) where T : IComparable<T>
{
    return a.CompareTo(b) > 0 ? a : b;
}

// Usage
var userRepo = new Repository<User>();
var maxValue = Max(10, 20);`,
            approaches: [
                "Use generics for code that works with multiple types.",
                "Apply constraints to ensure type safety and enable specific operations.",
                "Prefer generic collections (List<T>, Dictionary<K,V>) over non-generic ones.",
                "Use generic methods for algorithms that work with multiple types.",
                "Consider covariance and contravariance for interfaces."
            ]
        });

        // Q19 - Explain C# delegates, events, and lambda expressions
        questions.push({
            number: 19,
            title: "Explain C# delegates, events, and lambda expressions",
            description:
                "Delegates are type-safe function pointers that can reference methods. " +
                "Events are a special type of delegate that follow the observer pattern. " +
                "Lambda expressions provide a concise way to write anonymous functions.",
            why:
                "Delegates and events enable event-driven programming and decoupling. " +
                "Lambda expressions simplify code and are essential for LINQ and functional programming patterns.",
            what:
                "Delegates: Type-safe function pointers that can reference methods, support multicast. " +
                "Events: Special type of delegate, encapsulated delegate, follow observer pattern. " +
                "Lambda Expressions: Anonymous functions written with => syntax.",
            how:
                "Define delegates: public delegate void Notify(string message). " +
                "Use events: public event Notify OnNotify. " +
                "Use lambdas: var result = numbers.Select(x => x * x).",
            pros: [
                "Type-safe function references",
                "Enables event-driven programming",
                "Concise syntax with lambdas",
                "Essential for LINQ and functional programming"
            ],
            cons: [
                "Can make code harder to debug",
                "Memory leaks if events not unsubscribed",
                "Learning curve for complex scenarios"
            ],
            diagram: `flowchart TD
    A[Delegate Definition] --> B[Method Reference]
    A --> C[Lambda Expression]
    B --> D[Event Subscription]
    C --> D
    D --> E[Event Invocation]
    E --> F[Subscribed Methods Execute]`,
            implementation: `// Delegate definition
public delegate void Notify(string message);

// Event usage
public class Publisher
{
    public event Notify OnNotify;
    
    public void DoSomething()
    {
        OnNotify?.Invoke("Something happened");
    }
}

// Lambda expressions
Func<int, int> square = x => x * x;

// Used in LINQ
var numbers = new[] { 1, 2, 3, 4, 5 };
var squares = numbers.Select(x => x * x);

// Event subscription
var publisher = new Publisher();
publisher.OnNotify += message => Console.WriteLine(message);`,
            approaches: [
                "Use delegates for callback scenarios.",
                "Use events for observer pattern implementations.",
                "Prefer lambda expressions for short, simple functions.",
                "Unsubscribe from events to prevent memory leaks.",
                "Use Action<T> and Func<T> for common delegate scenarios."
            ]
        });

        // Q20 - Explain C# reflection and attributes
        questions.push({
            number: 20,
            title: "Explain C# reflection and attributes",
            description:
                "Reflection allows you to inspect types, methods, and properties at runtime. " +
                "Attributes provide metadata that can be accessed via reflection. " +
                "Together, they enable frameworks like ASP.NET Core, Entity Framework, and serialization libraries.",
            why:
                "Reflection and attributes are fundamental to many .NET frameworks. " +
                "Understanding them is crucial for building extensible systems and working with existing frameworks.",
            what:
                "Reflection: Inspect types at runtime, access metadata, create instances dynamically. " +
                "Attributes: Metadata annotations applied to types and members, accessible via reflection.",
            how:
                "Use typeof() to get Type objects. " +
                "Use GetProperties(), GetMethods() to inspect members. " +
                "Apply attributes with [AttributeName] syntax. " +
                "Access attributes via GetCustomAttributes().",
            pros: [
                "Enables dynamic type inspection",
                "Foundation for many frameworks",
                "Allows metadata-driven programming",
                "Enables extensibility"
            ],
            cons: [
                "Performance overhead",
                "No compile-time checking",
                "Can make code harder to understand",
                "Security considerations"
            ],
            diagram: `flowchart TD
    A[Type Definition] --> B[Attributes Applied]
    B --> C[Reflection API]
    C --> D[GetType]
    C --> E[GetProperties]
    C --> F[GetCustomAttributes]
    D --> G[Runtime Inspection]
    E --> G
    F --> G`,
            implementation: `// Attributes
[Serializable]
[Author("John Doe")]
public class MyClass
{
    [Required]
    [MaxLength(100)]
    public string Name { get; set; }
}

// Reflection
Type type = typeof(MyClass);
PropertyInfo[] properties = type.GetProperties();
MethodInfo method = type.GetMethod("MyMethod");
object instance = Activator.CreateInstance(type);

// Accessing attributes
var attributes = type.GetCustomAttributes(typeof(AuthorAttribute), false);
var author = (AuthorAttribute)attributes[0];`,
            approaches: [
                "Use reflection sparingly due to performance overhead.",
                "Cache reflection results when possible.",
                "Use attributes for metadata that frameworks can consume.",
                "Consider source generators as an alternative to runtime reflection.",
                "Be aware of security implications of reflection."
            ]
        });

        // Generic topics for Q21â€“Q50
        const advancedTopics = [
            "CQRS and MediatR-based architecture in .NET",
            "Domain-driven design layers in a .NET Core solution",
            "Outbox pattern for reliable messaging with EF Core",
            "Saga or process manager orchestration using background workers",
            "Resilience with Polly for retries, circuit breakers, and timeouts",
            "Caching strategies (in-memory, distributed, response caching)",
            "Security with JWT authentication and role-based authorization",
            "Using Span<T> and Memory<T> for high-performance APIs",
            "Records versus classes for immutable DTOs and domain objects",
            "ValueTask versus Task and when to use them",
            "Source generators and compile-time optimizations",
            "LINQ pitfalls and performance considerations",
            "Custom model binding and validation attributes",
            "File upload and download streaming in ASP.NET Core",
            "gRPC versus REST in modern .NET",
            "SignalR real-time communication in .NET",
            "Configuration for multi-tenant applications",
            "Localization and globalization strategy",
            "Logging correlation across microservices",
            "OpenTelemetry tracing with .NET",
            "Structuring large solutions (modular monolith vs microservices)",
            "Using feature flags and toggles in .NET applications",
            "Hosting .NET in containers and Kubernetes",
            "Performance profiling and dotnet-trace or dotnet-counters",
            "Memory leak diagnosis with dotnet-gcdump",
            "Async streams (IAsyncEnumerable) in APIs",
            "Pipeline behaviors in MediatR for cross-cutting concerns",
            "Dynamic loading and plugins with AssemblyLoadContext",
            "Implementing clean architecture in .NET",
            "Zero-downtime deployments for .NET APIs",
            "Rate limiting middleware in modern .NET",
            "Using keyed services and advanced DI patterns",
            "Multi-environment configuration and secrets management",
            "Backend for Frontend (BFF) pattern in .NET",
            "GraphQL endpoints with Hot Chocolate",
            "Testing strategy (unit, integration, contract tests)",
            "Using test containers (Docker) for integration tests",
            "Data protection APIs and cookie encryption",
            "Custom authentication handlers and schemes"
        ];

        // Enhanced question templates with detailed content
        const detailedQuestionTemplates = {
            "CQRS and MediatR-based architecture in .NET": {
                description: "CQRS (Command Query Responsibility Segregation) separates read and write operations. MediatR is a popular .NET library that implements the mediator pattern, enabling CQRS by routing requests to appropriate handlers. This pattern improves scalability and allows independent optimization of read and write paths.",
                why: "CQRS is essential for high-performance systems where read and write workloads differ significantly. MediatR simplifies implementation by providing a clean way to handle commands and queries without tight coupling between components.",
                what: "CQRS separates commands (write operations) from queries (read operations). MediatR acts as a mediator, routing requests to appropriate handlers. Commands change state, queries return data without side effects.",
                how: "Define command and query classes, create handlers implementing IRequestHandler, register MediatR services, and use IMediator to send requests. Use separate read and write models for optimal performance.",
                implementation: `// Command
public class CreateOrderCommand : IRequest<OrderDto>
{
    public string CustomerId { get; set; }
    public List<OrderItemDto> Items { get; set; }
}

// Command Handler
public class CreateOrderCommandHandler : IRequestHandler<CreateOrderCommand, OrderDto>
{
    private readonly IOrderRepository _repository;
    
    public CreateOrderCommandHandler(IOrderRepository repository)
    {
        _repository = repository;
    }
    
    public async Task<OrderDto> Handle(CreateOrderCommand request, CancellationToken cancellationToken)
    {
        var order = new Order { CustomerId = request.CustomerId };
        await _repository.AddAsync(order);
        return MapToDto(order);
    }
}

// Query
public class GetOrderQuery : IRequest<OrderDto>
{
    public int OrderId { get; set; }
}

// Query Handler
public class GetOrderQueryHandler : IRequestHandler<GetOrderQuery, OrderDto>
{
    private readonly IOrderReadRepository _readRepository;
    
    public async Task<OrderDto> Handle(GetOrderQuery request, CancellationToken cancellationToken)
    {
        return await _readRepository.GetByIdAsync(request.OrderId);
    }
}

// Usage in Controller
[HttpPost]
public async Task<IActionResult> CreateOrder(CreateOrderCommand command)
{
    var result = await _mediator.Send(command);
    return Ok(result);
}

// Registration
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly()));`
            },
            "Using Span<T> and Memory<T> for high-performance APIs": {
                description: "Span<T> and Memory<T> are stack-allocated and heap-allocated slices respectively, enabling zero-copy operations on arrays and memory buffers. They are crucial for high-performance scenarios where avoiding allocations is critical.",
                why: "In high-throughput APIs, memory allocations can become a bottleneck. Span<T> and Memory<T> allow working with data without copying, significantly improving performance in scenarios like parsing, serialization, and data transformation.",
                what: "Span<T> is a stack-only struct that provides a view over contiguous memory. Memory<T> is similar but can be stored on the heap. Both enable zero-copy operations and are essential for performance-critical code.",
                how: "Use Span<T> for stack-allocated scenarios and Memory<T> when you need to store references. Convert arrays to spans, use ReadOnlySpan for immutable operations, and leverage stackalloc for small buffers.",
                implementation: `// Using Span<T> for zero-copy parsing
public static int ParseInt(ReadOnlySpan<char> span)
{
    int result = 0;
    foreach (var c in span)
    {
        if (char.IsDigit(c))
        {
            result = result * 10 + (c - '0');
        }
    }
    return result;
}

// Usage
var text = "12345";
var span = text.AsSpan();
var number = ParseInt(span);

// Using Memory<T> for async scenarios
public async Task ProcessDataAsync(Memory<byte> data)
{
    // Can be stored and passed to async methods
    await ProcessChunkAsync(data.Slice(0, 100));
}

// Stack allocation for small buffers
Span<byte> buffer = stackalloc byte[256];
ProcessBuffer(buffer);`
            },
            "Records versus classes for immutable DTOs and domain objects": {
                description: "C# records provide a concise way to create immutable reference types with value-based equality. They are ideal for DTOs, value objects, and immutable domain entities where equality is based on values rather than reference identity.",
                why: "Records reduce boilerplate code for immutable types, provide built-in value equality, and make intent clear. They are perfect for DTOs, API responses, and value objects in domain-driven design.",
                what: "Records are reference types with value semantics. They automatically generate equality members, ToString(), and support with expressions for creating modified copies. Classes are better for mutable entities with identity.",
                how: "Use records for DTOs, value objects, and immutable data. Use classes for entities with identity and mutable state. Leverage with expressions to create modified copies of records.",
                implementation: `// Record for DTO
public record OrderDto(
    int Id,
    string CustomerName,
    decimal Total,
    DateTime CreatedAt
);

// Value object as record
public record Money(decimal Amount, string Currency)
{
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Cannot add different currencies");
        return this with { Amount = Amount + other.Amount };
    }
}

// Class for entity with identity
public class Order
{
    public int Id { get; private set; }
    public string CustomerId { get; private set; }
    public OrderStatus Status { get; private set; }
    
    public void ChangeStatus(OrderStatus newStatus)
    {
        Status = newStatus;
    }
}

// Usage
var dto = new OrderDto(1, "John", 100.50m, DateTime.UtcNow);
var updated = dto with { Total = 150.00m }; // Creates new record`
            },
            "Custom authentication handlers and schemes": {
                description: "ASP.NET Core authentication is built on a scheme-based system where you can create custom authentication handlers. This allows implementing custom authentication logic such as API keys, custom tokens, or integration with external identity providers.",
                why: "Custom authentication handlers are essential when standard authentication schemes don't meet requirements. They enable integration with legacy systems, custom token formats, or specialized authentication protocols.",
                what: "Authentication handlers implement AuthenticationHandler<TOptions> and handle authentication challenges. Schemes are registered with AddAuthentication and can be combined. Handlers validate credentials and create authentication tickets.",
                how: "Create a custom handler class inheriting from AuthenticationHandler, implement HandleAuthenticateAsync, register the scheme with AddAuthentication().AddScheme(), and use [Authorize(AuthenticationSchemes = \"CustomScheme\")].",
                implementation: `// Custom authentication options
public class ApiKeyAuthenticationOptions : AuthenticationSchemeOptions
{
    public string ApiKeyHeaderName { get; set; } = "X-API-Key";
    public string ValidApiKey { get; set; } = string.Empty;
}

// Custom authentication handler
public class ApiKeyAuthenticationHandler : AuthenticationHandler<ApiKeyAuthenticationOptions>
{
    public ApiKeyAuthenticationHandler(
        IOptionsMonitor<ApiKeyAuthenticationOptions> options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock)
        : base(options, logger, encoder, clock)
    {
    }

    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        if (!Request.Headers.TryGetValue(Options.ApiKeyHeaderName, out var apiKeyHeaderValues))
        {
            return Task.FromResult(AuthenticateResult.Fail("API Key was not provided"));
        }

        var providedApiKey = apiKeyHeaderValues.ToString();
        if (providedApiKey != Options.ValidApiKey)
        {
            return Task.FromResult(AuthenticateResult.Fail("Invalid API Key"));
        }

        var claims = new[] { new Claim(ClaimTypes.Name, "ApiUser") };
        var identity = new ClaimsIdentity(claims, Scheme.Name);
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, Scheme.Name);

        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}

// Registration
builder.Services.AddAuthentication("ApiKey")
    .AddScheme<ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler>(
        "ApiKey", options => 
        {
            options.ValidApiKey = builder.Configuration["ApiKey"];
        });

// Usage
[Authorize(AuthenticationSchemes = "ApiKey")]
[ApiController]
public class SecureController : ControllerBase
{
    [HttpGet]
    public IActionResult Get() => Ok("Authenticated");
}`
            }
        };

        function generateGenericQuestion(index, topic) {
            // Check if we have detailed template for this topic
            const detailedTemplate = detailedQuestionTemplates[topic];
            
            if (detailedTemplate) {
                return {
                    number: index,
                    title: `How would you implement and reason about ${topic} in a real-world .NET Core system?`,
                    description: detailedTemplate.description,
                    why: detailedTemplate.why,
                    what: detailedTemplate.what,
                    how: detailedTemplate.how,
                    pros: [
                        "Improved separation of concerns and testability",
                        "Better resilience and fault tolerance in production",
                        "Easier evolution of the system as requirements change",
                        "Clearer boundaries between domain and infrastructure",
                        "Enhanced performance and scalability"
                    ],
                    cons: [
                        "Higher initial complexity and learning curve",
                        "More moving parts to monitor and operate",
                        "Risk of over-engineering for small systems",
                        "Requires strong team discipline and documentation",
                        "Additional abstraction layers to understand"
                    ],
                    diagram: `flowchart TD
    A["API Layer"] --> B["Application Layer"]
    B --> C["Domain Layer"]
    B --> D["Infrastructure Layer"]
    D --> E["External Systems"]`,
                    implementation: detailedTemplate.implementation,
                    approaches: [
                        "Start from domain use-cases and derive where this pattern fits.",
                        "Implement a vertical slice end to end before generalizing.",
                        "Add observability from day one using logs, metrics, and traces.",
                        "Document the decision in an architecture decision record.",
                        "Continuously review and simplify patterns that are not pulling their weight.",
                        "Consider performance implications and measure before optimizing."
                    ]
                };
            }
            
            // Default generic question
            return {
                number: index,
                title: `How would you implement and reason about ${topic} in a real-world .NET Core system?`,
                description:
                    `${topic} is a common advanced requirement in enterprise .NET applications. ` +
                    `It affects how you design boundaries, handle reliability, and meet non-functional requirements ` +
                    `such as performance, security, and maintainability. Understanding this topic is crucial for building ` +
                    `scalable, maintainable, and performant .NET Core applications.`,
                why:
                    `Architects and senior engineers must understand ${topic} to make informed trade-offs between complexity, ` +
                    `operational cost, and long-term flexibility. Poor design here often surfaces as production issues ` +
                    `under load or during failures. This knowledge enables teams to build robust systems that can evolve over time.`,
                what:
                    `${topic} typically involves combining core .NET features (async and await, dependency injection, configuration, logging) ` +
                    `with architectural patterns such as clean architecture, domain-driven design, microservices, or modular monoliths. ` +
                    `The goal is to keep domain code clean while handling cross-cutting concerns in the infrastructure layer. ` +
                    `This requires deep understanding of .NET Core internals and best practices.`,
                how:
                    `In practice, you would design an abstraction in the application or domain layer and provide ` +
                    `one or more infrastructure implementations. You would register them via dependency injection with appropriate lifetimes, ` +
                    `configure them via options pattern, and validate their behavior via integration tests. Observability ` +
                    `is added via middleware, filters, or pipeline behaviors. Performance optimization involves profiling, ` +
                    `caching strategies, and efficient resource management.`,
                pros: [
                    "Improved separation of concerns and testability",
                    "Better resilience and fault tolerance in production",
                    "Easier evolution of the system as requirements change",
                    "Clearer boundaries between domain and infrastructure",
                    "Enhanced performance through optimized patterns"
                ],
                cons: [
                    "Higher initial complexity and learning curve",
                    "More moving parts to monitor and operate",
                    "Risk of over-engineering for small systems",
                    "Requires strong team discipline and documentation",
                    "Additional cognitive overhead for team members"
                ],
                diagram: `flowchart TD
    A["API Layer"] --> B["Application Layer"]
    B --> C["Domain Layer"]
    B --> D["Infrastructure Layer"]
    D --> E["External Systems"]`,
                implementation: `// Example implementation pattern for ${topic}

// Domain layer interface
public interface I${topic.replace(/[^a-zA-Z0-9]/g, '')}Service
{
    Task ProcessAsync(CancellationToken cancellationToken = default);
}

// Application layer implementation
public class ${topic.replace(/[^a-zA-Z0-9]/g, '')}Service : I${topic.replace(/[^a-zA-Z0-9]/g, '')}Service
{
    private readonly ILogger<${topic.replace(/[^a-zA-Z0-9]/g, '')}Service> _logger;
    private readonly IConfiguration _configuration;

    public ${topic.replace(/[^a-zA-Z0-9]/g, '')}Service(
        ILogger<${topic.replace(/[^a-zA-Z0-9]/g, '')}Service> logger,
        IConfiguration configuration)
    {
        _logger = logger;
        _configuration = configuration;
    }

    public async Task ProcessAsync(CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Processing: ${topic}");
        // Implementation specific to ${topic}
        await Task.CompletedTask;
    }
}

// Registration in Program.cs
builder.Services.AddScoped<I${topic.replace(/[^a-zA-Z0-9]/g, '')}Service, ${topic.replace(/[^a-zA-Z0-9]/g, '')}Service>();`,
                approaches: [
                    "Start from domain use-cases and derive where this pattern fits.",
                    "Implement a vertical slice end to end before generalizing.",
                    "Add observability from day one using logs, metrics, and traces.",
                    "Document the decision in an architecture decision record.",
                    "Continuously review and simplify patterns that are not pulling their weight.",
                    "Measure performance impact before and after implementation.",
                    "Consider team expertise and provide adequate training."
                ]
            };
        }

        let currentNumber = questions.length + 1;
        for (let i = 0; currentNumber <= 50; i++, currentNumber++) {
            const topic = advancedTopics[i % advancedTopics.length];
            questions.push(generateGenericQuestion(currentNumber, topic));
        }

        const tocList = document.getElementById('tocList');
        const container = document.getElementById('questionsContainer');

        questions.sort((a, b) => a.number - b.number);

        questions.forEach(q => {
            const link = document.createElement('a');
            link.href = `#question-${q.number}`;
            const shortTitle = q.title.length > 40 ? q.title.substring(0, 40) + "..." : q.title;
            link.textContent = `Q${q.number}: ${shortTitle}`;
            link.onclick = (e) => {
                e.preventDefault();
                document.getElementById(`question-${q.number}`)
                    .scrollIntoView({ behavior: 'smooth', block: 'start' });
            };
            tocList.appendChild(link);

            const card = document.createElement('div');
            card.className = 'question-card';
            card.id = `question-${q.number}`;

            card.innerHTML = `
                <div class="question-number">Question ${q.number} of 50</div>
                <h2 class="question-title">${q.title}</h2>

                <div class="question-section">
                    <h3>1. Detailed Description</h3>
                    <p>${q.description}</p>
                </div>

                <div class="question-section">
                    <h3>2. Why / What / How</h3>
                    <p><strong>Why:</strong> ${q.why}</p>
                    <p><strong>What:</strong> ${q.what}</p>
                    <p><strong>How:</strong> ${q.how}</p>
                </div>

                <div class="question-section">
                    <h3>3. Pros and Cons</h3>
                    <div class="pros-cons">
                        <div class="pros-box">
                            <h4>Pros</h4>
                            <ul>
                                ${q.pros.map(p => `<li>${p}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="cons-box">
                            <h4>Cons</h4>
                            <ul>
                                ${q.cons.map(c => `<li>${c}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="question-section">
                    <h3>4. Design Diagram</h3>
                    <div class="diagram-container">
                        <div class="diagram-title">Architecture Diagram</div>
                        <div class="mermaid" data-diagram="${q.diagram.replace(/"/g, '&quot;').replace(/\n/g, '\\n').replace(/</g, '&lt;').replace(/>/g, '&gt;')}">${q.diagram}</div>
                    </div>
                </div>

                <div class="question-section">
                    <h3>5. Implementation (C#)</h3>
                    <div class="code-block">
                        <pre><code>${q.implementation}</code></pre>
                    </div>
                </div>

                <div class="question-section">
                    <h3>6. Approaches</h3>
                    <ul>
                        ${q.approaches.map(a => `<li>${a}</li>`).join('')}
                    </ul>
                </div>
            `;

            container.appendChild(card);
        });

        // Function to apply black text styling to rendered SVG
        function applyBlackTextStyling(svg) {
            if (!svg) return;
            
            // Set SVG background to white
            svg.style.backgroundColor = '#ffffff';
            
            // Force all text to black
            const allTexts = svg.querySelectorAll('text, tspan');
            allTexts.forEach(text => {
                text.setAttribute('fill', '#000000');
                text.style.fill = '#000000';
                text.style.color = '#000000';
            });
            
            // Update node styles
            const nodes = svg.querySelectorAll('.node rect, .node circle, .node ellipse, .cluster rect');
            nodes.forEach(node => {
                node.setAttribute('fill', '#ffffff');
                node.setAttribute('stroke', '#000000');
                node.style.fill = '#ffffff';
                node.style.stroke = '#000000';
            });
            
            // Update edge colors
            const edges = svg.querySelectorAll('.edgePath .path, .edgePath marker path, line');
            edges.forEach(edge => {
                edge.setAttribute('stroke', '#000000');
                edge.style.stroke = '#000000';
            });
            
            // Update arrowheads
            const arrows = svg.querySelectorAll('.arrowheadPath, marker path');
            arrows.forEach(arrow => {
                arrow.setAttribute('fill', '#000000');
                arrow.style.fill = '#000000';
            });
        }

        // Initialize and render mermaid diagrams
        function renderMermaidDiagrams() {
            // Check if mermaid is loaded
            if (typeof mermaid === 'undefined') {
                console.error('Mermaid library not loaded');
                return;
            }

            // Log mermaid version info for debugging
            console.log('Mermaid loaded. Available methods:', Object.keys(mermaid).filter(k => typeof mermaid[k] === 'function'));

            // Initialize Mermaid
            mermaid.initialize({
                startOnLoad: false,
                theme: "default",
                themeVariables: {
                    primaryColor: "#ffffff",
                    primaryTextColor: "#000000",
                    primaryBorderColor: "#000000",
                    lineColor: "#000000",
                    secondaryColor: "#f0f0f0",
                    tertiaryColor: "#ffffff",
                    textColor: "#000000",
                    mainBkg: "#ffffff",
                    secondBkg: "#f0f0f0",
                    tertiaryBkg: "#ffffff"
                },
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true,
                    curve: 'basis',
                    nodeSpacing: 50,
                    rankSpacing: 50
                }
            });

            // Get all mermaid elements
            const mermaidElements = document.querySelectorAll('.mermaid');
            console.log(`Found ${mermaidElements.length} mermaid diagrams to render`);
            
            if (mermaidElements.length === 0) {
                console.warn('No mermaid diagrams found');
                return;
            }

            // Render each diagram individually using Promise.all for better error handling
            const renderPromises = Array.from(mermaidElements).map(async (element, index) => {
                try {
                    // Get the diagram definition from data attribute first (cleanest source)
                    // If not available, get from textContent
                    let graphDefinition = element.getAttribute('data-diagram');
                    
                    // If data attribute exists, unescape it
                    if (graphDefinition) {
                        graphDefinition = graphDefinition.replace(/\\n/g, '\n')
                            .replace(/&quot;/g, '"')
                            .replace(/&lt;/g, '<')
                            .replace(/&gt;/g, '>');
                    } else {
                        // Fallback to textContent
                        graphDefinition = element.textContent || element.innerText || '';
                    }
                    
                    // Clean the definition - remove any CSS or style tags that might have been injected
                    graphDefinition = graphDefinition.trim();
                    
                    // Remove any CSS styles that might be in the text (from previous failed renders)
                    graphDefinition = graphDefinition.replace(/#mermaid-\d+{[^}]*}/g, '');
                    graphDefinition = graphDefinition.replace(/#mermaid-\d+\s*\{[^}]*\}/g, '');
                    graphDefinition = graphDefinition.replace(/\{[^}]*font[^}]*\}/gi, '');
                    graphDefinition = graphDefinition.replace(/\{[^}]*fill[^}]*\}/gi, '');
                    
                    // Find the actual diagram definition - it should start with a diagram type
                    const diagramTypes = ['flowchart', 'graph', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'erDiagram', 'journey', 'gantt', 'pie', 'gitgraph', 'requirement'];
                    let cleanDefinition = '';
                    
                    // Look for diagram type at the start or after whitespace
                    for (const type of diagramTypes) {
                        const regex = new RegExp(`^\\s*${type}[\\s\\n]`, 'i');
                        if (regex.test(graphDefinition)) {
                            // Found at start, use it
                            cleanDefinition = graphDefinition.trim();
                            break;
                        }
                        const index = graphDefinition.toLowerCase().indexOf(type);
                        if (index !== -1) {
                            // Found diagram type, extract from here
                            cleanDefinition = graphDefinition.substring(index).trim();
                            break;
                        }
                    }
                    
                    // If still no clean definition, use the original but validate it
                    if (!cleanDefinition) {
                        cleanDefinition = graphDefinition.trim();
                    }
                    
                    // Validate that it starts with a diagram type
                    const startsWithDiagramType = diagramTypes.some(type => 
                        cleanDefinition.toLowerCase().trim().startsWith(type.toLowerCase())
                    );
                    
                    if (!startsWithDiagramType) {
                        console.warn(`Diagram ${index} doesn't start with a valid diagram type.`);
                        console.warn('Content preview:', cleanDefinition.substring(0, 200));
                        element.innerHTML = '<div style="color: #e0e0e0; padding: 20px; text-align: center; border: 1px solid #ffaa00;">' +
                            '<p style="color: #ffaa00;">Invalid diagram format.</p>' +
                            '<p style="font-size: 11px; color: #999;">Diagram must start with: flowchart, graph, sequenceDiagram, etc.</p>' +
                            '</div>';
                        return;
                    }
                    
                    if (!cleanDefinition) {
                        console.warn(`Empty mermaid diagram at index ${index}`);
                        return;
                    }
                    
                    // Generate unique ID for this diagram
                    const id = 'mermaid-' + index + '-' + Date.now();
                    
                    console.log(`Rendering diagram ${index}, definition length: ${cleanDefinition.length}`);
                    
                    // Use mermaid.render() API - this is the most reliable method
                    try {
                        const result = await mermaid.render(id, cleanDefinition);
                        // mermaid.render() returns {svg, bindFunctions}
                        if (result && result.svg) {
                            element.innerHTML = result.svg;
                            
                            // Apply black text styling
                            const svgElement = element.querySelector('svg');
                            if (svgElement) {
                                applyBlackTextStyling(svgElement);
                            }
                        } else {
                            throw new Error('Invalid result from mermaid.render()');
                        }
                    } catch (renderError) {
                        console.error(`Error rendering diagram ${index}:`, renderError);
                        console.error('Clean diagram definition (first 300 chars):', cleanDefinition.substring(0, 300));
                        console.error('Original text (first 300 chars):', graphDefinition.substring(0, 300));
                        
                        // Show error message with diagram text for debugging
                        element.innerHTML = '<div style="color: #e0e0e0; padding: 20px; text-align: center; border: 1px solid #ff4444; background: rgba(255,68,68,0.1);">' +
                            '<p style="color: #ff4444; font-weight: bold;">Diagram rendering error</p>' +
                            '<p style="font-size: 11px; color: #999; margin-top: 10px;">Index: ' + index + '</p>' +
                            '<details style="margin-top: 10px; text-align: left;"><summary style="cursor: pointer; color: #00d4ff;">Show error details</summary>' +
                            '<pre style="font-size: 10px; color: #ccc; margin-top: 5px; overflow-x: auto; max-height: 200px;">' + 
                            (renderError.message || String(renderError)) + 
                            '</pre></details>' +
                            '</div>';
                    }
                } catch (error) {
                    console.error(`Error processing diagram ${index}:`, error);
                    element.innerHTML = '<div style="color: #e0e0e0; padding: 20px; text-align: center;">' +
                        '<p>Diagram processing error.</p>' +
                        '</div>';
                }
            });
            
            // Wait for all diagrams to render
            Promise.all(renderPromises).then(() => {
                console.log('All mermaid diagrams processed');
            }).catch((error) => {
                console.error('Error in mermaid rendering batch:', error);
            });
        }

        // Wait for everything to be ready
        function initMermaid() {
            // Wait for mermaid library
            if (typeof mermaid === 'undefined') {
                setTimeout(initMermaid, 100);
                return;
            }
            
            // Wait a bit more for DOM to be fully ready
            setTimeout(renderMermaidDiagrams, 300);
        }

        // Start initialization
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initMermaid);
        } else {
            initMermaid();
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure Service Bus - 50 Advanced Interview Questions | Chandan Kumar</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --primary-color: #00d4ff; --secondary-color: #0099cc; --neon-blue: #00d4ff; --dark-blue: #0a1929; --darker-blue: #051422; }
        body { font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, Arial, sans-serif; background: var(--darker-blue); color: #e0e0e0; line-height: 1.6; overflow-x: hidden; position: relative; }
        .animated-bg { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; background: var(--darker-blue); background-image: url('background-image.jpg'); background-size: cover; background-position: center; background-repeat: no-repeat; background-color: var(--darker-blue); }
        .animated-bg::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: radial-gradient(circle at 20% 30%, rgba(0, 212, 255, 0.1) 0%, transparent 50%), radial-gradient(circle at 80% 70%, rgba(0, 153, 204, 0.1) 0%, transparent 50%); opacity: 0.6; }
        .animated-bg::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(0, 212, 255, 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 212, 255, 0.03) 1px, transparent 1px); background-size: 50px 50px; opacity: 0.4; }
        nav { position: fixed; top: 0; width: 100%; background: rgba(10, 25, 41, 0.85); backdrop-filter: blur(10px); box-shadow: 0 2px 20px rgba(0, 212, 255, 0.2); border-bottom: 1px solid rgba(0, 212, 255, 0.2); z-index: 1000; padding: 15px 0; }
        .nav-container { max-width: 1200px; margin: 0 auto; padding: 0 30px; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 24px; font-weight: 700; background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .back-btn { color: rgba(255, 255, 255, 0.9); text-decoration: none; font-weight: 500; display: flex; align-items: center; gap: 8px; transition: all 0.3s ease; }
        .back-btn:hover { color: var(--neon-blue); text-shadow: 0 0 10px rgba(0, 212, 255, 0.8); }
        .container { max-width: 1200px; margin: 0 auto; padding: 120px 30px 60px; }
        .page-header { text-align: center; margin-bottom: 60px; padding: 40px 0; }
        .page-icon { font-size: 80px; margin-bottom: 30px; color: var(--neon-blue); text-shadow: 0 0 30px rgba(0, 212, 255, 0.8); }
        .page-title { font-size: 48px; font-weight: 800; margin-bottom: 20px; color: var(--neon-blue); text-shadow: 0 0 20px rgba(0, 212, 255, 0.8); }
        .page-subtitle { font-size: 20px; opacity: 0.9; color: #e0e0e0; }
        .question-card { background: rgba(10, 25, 41, 0.6); backdrop-filter: blur(5px); border-radius: 15px; padding: 40px; margin-bottom: 40px; box-shadow: 0 8px 32px rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.2); }
        .question-number { color: var(--neon-blue); font-size: 18px; font-weight: 700; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); }
        .question-title { font-size: 28px; font-weight: 700; color: var(--neon-blue); margin-bottom: 25px; }
        .question-section { margin-bottom: 30px; }
        .question-section h3 { font-size: 22px; color: var(--neon-blue); margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px; }
        .question-section p { font-size: 16px; line-height: 1.8; color: #e0e0e0; margin-bottom: 15px; }
        .question-section ul { list-style: none; padding-left: 0; }
        .question-section li { font-size: 16px; line-height: 1.8; margin-bottom: 12px; padding-left: 25px; position: relative; color: #e0e0e0; }
        .question-section li::before { content: '▸'; position: absolute; left: 0; color: var(--neon-blue); font-weight: bold; }
        .pros-cons { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .pros-box, .cons-box { padding: 20px; border-radius: 10px; }
        .pros-box { background: rgba(0, 255, 0, 0.1); border: 2px solid rgba(0, 255, 0, 0.3); }
        .cons-box { background: rgba(255, 0, 0, 0.1); border: 2px solid rgba(255, 0, 0, 0.3); }
        .pros-box h4 { color: #00ff00; margin-bottom: 15px; font-size: 18px; }
        .cons-box h4 { color: #ff4444; margin-bottom: 15px; font-size: 18px; }
        .diagram-container { background: rgba(5, 20, 34, 0.8); border-radius: 15px; padding: 30px; margin: 25px 0; border: 2px solid rgba(0, 212, 255, 0.3); }
        .diagram-title { font-size: 18px; font-weight: 700; color: var(--neon-blue); margin-bottom: 15px; text-align: center; }
        .mermaid { background: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 10px; }
        .code-block { background: rgba(0, 0, 0, 0.5); border-radius: 10px; padding: 20px; margin: 20px 0; border-left: 4px solid var(--neon-blue); overflow-x: auto; }
        .code-block pre { color: #e0e0e0; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.6; white-space: pre-wrap; }
        .code-block code { color: #e0e0e0; }
        .highlight-box { background: rgba(0, 212, 255, 0.1); border-left: 4px solid var(--neon-blue); padding: 20px; margin: 20px 0; border-radius: 5px; }
        .toc { background: rgba(10, 25, 41, 0.6); backdrop-filter: blur(5px); border-radius: 15px; padding: 30px; margin-bottom: 40px; border: 1px solid rgba(0, 212, 255, 0.2); }
        .toc h2 { color: var(--neon-blue); margin-bottom: 20px; }
        .toc-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; }
        .toc-list a { color: #e0e0e0; text-decoration: none; padding: 8px 12px; border-radius: 5px; transition: all 0.3s ease; display: block; }
        .toc-list a:hover { background: rgba(0, 212, 255, 0.2); color: var(--neon-blue); }
        @media (max-width: 768px) { .page-title { font-size: 32px; } .question-card { padding: 25px 20px; } .pros-cons { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div class="animated-bg"></div>
    <nav>
        <div class="nav-container">
            <div class="logo">Chandan Kumar</div>
            <a href="index.html" class="back-btn"><i class="fas fa-arrow-left"></i> Back to Home</a>
        </div>
    </nav>

    <div class="container">
        <div class="page-header">
            <div class="page-icon"><i class="fas fa-exchange-alt"></i></div>
            <h1 class="page-title">Azure Service Bus</h1>
            <p class="page-subtitle">50 Advanced C# Interview Questions &amp; Answers</p>
        </div>

        <!-- Table of Contents -->
        <div class="toc">
            <h2>Table of Contents</h2>
            <div class="toc-list" id="tocList"></div>
        </div>

        <!-- Questions Container -->
        <div id="questionsContainer"></div>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({
            startOnLoad: false,
            securityLevel: "loose",
            theme: "dark",
            themeVariables: {
                primaryColor: "#00d4ff",
                primaryTextColor: "#e0e0e0",
                primaryBorderColor: "#0099cc",
                lineColor: "#00d4ff",
                secondaryColor: "#051422",
                tertiaryColor: "#0a1929"
            }
        });

        // Questions 1–7 (fully detailed)
        const questions = [
            {
                number: 1,
                title: "What is Azure Service Bus and how does it differ from Azure Storage Queues?",
                description: "Azure Service Bus is a cloud messaging service that provides reliable message queuing and publish/subscribe capabilities. Unlike Azure Storage Queues, Service Bus offers advanced features like topics, subscriptions, sessions, and dead-letter queues. Service Bus is designed for enterprise messaging scenarios requiring guaranteed delivery, ordering, and complex routing patterns.",
                why: "Understanding the difference is crucial because choosing the wrong messaging service can lead to architectural issues, performance problems, or unnecessary costs. Service Bus is ideal for enterprise scenarios requiring advanced features, while Storage Queues are better for simple, high-volume scenarios.",
                what: "Azure Service Bus is a fully managed enterprise message broker with queue and publish-subscribe capabilities. It supports multiple messaging patterns including point-to-point (queues) and publish-subscribe (topics/subscriptions). Storage Queues are simple REST-based queues built on Azure Storage.",
                how: "Service Bus provides advanced features like message sessions for ordered processing, dead-letter queues for failed messages, duplicate detection, scheduled delivery, and auto-forwarding. Storage Queues provide basic FIFO queuing with simple REST APIs.",
                pros: [
                    "Advanced messaging patterns (topics, subscriptions, sessions)",
                    "Guaranteed message delivery with at-least-once semantics",
                    "Dead-letter queue support for failed messages",
                    "Message ordering with sessions",
                    "Duplicate detection",
                    "Scheduled message delivery",
                    "Auto-forwarding and routing capabilities",
                    "Better integration with Azure services"
                ],
                cons: [
                    "Higher cost compared to Storage Queues",
                    "More complex configuration and management",
                    "Message size limit of 256 KB (1 MB for Premium)",
                    "Requires more learning curve",
                    "Potential latency compared to in-memory solutions",
                    "Requires proper connection management"
                ],
                diagram: `flowchart TD
    A[Application] -->|Send| B[Service Bus Queue]
    B -->|Receive| C[Consumer App]
    D[Publisher] -->|Publish| E[Service Bus Topic]
    E -->|Subscribe| F[Subscription 1]
    E -->|Subscribe| G[Subscription 2]
    F --> H[Consumer 1]
    G --> I[Consumer 2]
    B -->|Failed| J[Dead Letter Queue]`,
                implementation: `using Azure.Messaging.ServiceBus;
using System.Text.Json;

// Service Bus Queue Example
var connectionString = "Endpoint=sb://myservicebus.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=...";
var queueName = "orders-queue";

await using var client = new ServiceBusClient(connectionString);

// Send message
await using var sender = client.CreateSender(queueName);
var order = new { OrderId = 12345, CustomerId = "C001", Amount = 99.99 };
var message = new ServiceBusMessage(JsonSerializer.Serialize(order))
{
    MessageId = order.OrderId.ToString(),
    Subject = "NewOrder"
};
await sender.SendMessageAsync(message);

// Receive messages
await using var processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions
{
    MaxConcurrentCalls = 1,
    AutoCompleteMessages = false
});

processor.ProcessMessageAsync += async args =>
{
    try
    {
        var body = args.Message.Body.ToString();
        var orderData = JsonSerializer.Deserialize<Order>(body);
        // Process order
        await args.CompleteMessageAsync(args.Message);
    }
    catch (Exception ex)
    {
        await args.AbandonMessageAsync(args.Message);
        // Log error
    }
};

processor.ProcessErrorAsync += args =>
{
    Console.WriteLine(args.Exception.Message);
    return Task.CompletedTask;
};

await processor.StartProcessingAsync();`,
                approaches: [
                    "Use Service Bus Queues for point-to-point messaging with guaranteed delivery",
                    "Use Service Bus Topics/Subscriptions for publish-subscribe patterns",
                    "Use Storage Queues for simple, high-volume scenarios with lower cost",
                    "Use Service Bus Sessions for ordered message processing",
                    "Implement dead-letter queues for error handling and retry logic",
                    "Use message batching for improved throughput",
                    "Implement connection pooling and reuse ServiceBusClient instances"
                ]
            },
            {
                number: 2,
                title: "Explain the difference between Service Bus Queues and Topics/Subscriptions",
                description: "Service Bus Queues provide point-to-point messaging where each message is consumed by a single consumer. Topics and Subscriptions provide publish-subscribe messaging where a message published to a topic is delivered to all subscriptions, enabling one-to-many communication patterns.",
                why: "Choosing the right messaging pattern is essential for system architecture. Queues are for load distribution, while Topics/Subscriptions are for event broadcasting and multi-consumer scenarios.",
                what: "Queues implement point-to-point messaging - one sender, one receiver. Topics implement publish-subscribe - one publisher, multiple subscribers. Each subscription receives a copy of messages matching its filter rules.",
                how: "Create a queue for direct messaging. Create a topic and multiple subscriptions for broadcasting. Use subscription filters to route messages to specific subscribers based on message properties.",
                pros: [
                    "Queues: Simple point-to-point communication",
                    "Queues: Load balancing across multiple consumers",
                    "Topics: One-to-many message distribution",
                    "Topics: Message filtering per subscription",
                    "Topics: Independent message processing per subscription",
                    "Topics: Support for multiple consumer groups"
                ],
                cons: [
                    "Queues: Limited to single consumer per message",
                    "Topics: More complex configuration",
                    "Topics: Higher cost with multiple subscriptions",
                    "Topics: Requires filter management",
                    "Both: Need proper error handling",
                    "Both: Message ordering challenges"
                ],
                diagram: `flowchart TD
    A[Producer] -->|Send| B[Queue]
    B -->|Receive| C[Consumer 1]
    B -->|Receive| D[Consumer 2]
    E[Publisher] -->|Publish| F[Topic]
    F -->|Filter| G[Subscription 1]
    F -->|Filter| H[Subscription 2]
    F -->|Filter| I[Subscription 3]
    G --> J[Consumer A]
    H --> K[Consumer B]
    I --> L[Consumer C]`,
                implementation: `using Azure.Messaging.ServiceBus;

// Queue Example
var queueClient = new ServiceBusClient(connectionString);
await using var queueSender = queueClient.CreateSender("orders-queue");
await queueSender.SendMessageAsync(new ServiceBusMessage("Order data"));

// Topic/Subscription Example
await using var topicSender = queueClient.CreateSender("order-events");
var message = new ServiceBusMessage("Order created")
{
    ApplicationProperties =
    {
        { "EventType", "OrderCreated" },
        { "Priority", "High" }
    }
};
await topicSender.SendMessageAsync(message);

// Subscription with processor
await using var subscriptionProcessor = queueClient.CreateProcessor("order-events", "high-priority-orders", new ServiceBusProcessorOptions
{
    MaxConcurrentCalls = 1
});

subscriptionProcessor.ProcessMessageAsync += async args =>
{
    if (args.Message.ApplicationProperties.ContainsKey("Priority") &&
        args.Message.ApplicationProperties["Priority"].ToString() == "High")
    {
        // Process high priority order
        await args.CompleteMessageAsync(args.Message);
    }
    else
    {
        await args.AbandonMessageAsync(args.Message);
    }
};

subscriptionProcessor.ProcessErrorAsync += args =>
{
    Console.WriteLine(args.Exception.Message);
    return Task.CompletedTask;
};

await subscriptionProcessor.StartProcessingAsync();`,
                approaches: [
                    "Use Queues when you need load balancing and single consumer per message",
                    "Use Topics when you need to broadcast events to multiple consumers",
                    "Use Subscription Filters to route messages to specific subscribers",
                    "Combine Queues and Topics for complex routing scenarios",
                    "Use Auto-forwarding to chain Queues and Topics",
                    "Implement message versioning for Topics to handle schema evolution"
                ]
            },
            {
                number: 3,
                title: "How do you implement dead-letter queues in Azure Service Bus?",
                description: "Dead-letter queues (DLQ) are sub-queues that store messages that cannot be delivered or processed successfully. Service Bus automatically moves messages to DLQ when they exceed max delivery count, expire, or are explicitly dead-lettered. DLQ helps with error analysis, debugging, and implementing retry patterns.",
                why: "Dead-letter queues are essential for production systems to handle failures gracefully, prevent message loss, enable debugging, and implement retry strategies without blocking the main queue.",
                what: "A dead-letter queue is a special sub-queue that stores failed messages. Messages are moved to DLQ when max delivery attempts are exceeded, TTL expires, or explicitly dead-lettered by the application.",
                how: "Configure MaxDeliveryCount on queue/subscription. Handle ProcessErrorAsync events. Manually dead-letter messages using DeadLetterMessageAsync. Retrieve messages from DLQ using a separate processor pointing to the dead-letter sub-queue.",
                pros: [
                    "Prevents message loss from processing failures",
                    "Enables error analysis and debugging",
                    "Allows manual reprocessing of failed messages",
                    "Prevents queue blocking from poison messages",
                    "Provides audit trail for failed operations",
                    "Supports retry pattern implementation"
                ],
                cons: [
                    "Requires additional monitoring and management",
                    "Can accumulate messages if not monitored",
                    "Additional storage costs",
                    "Requires separate processing logic",
                    "Need to handle DLQ message format differences",
                    "Potential for message duplication if reprocessed incorrectly"
                ],
                diagram: `flowchart TD
    A[Message] -->|Send| B[Service Bus Queue]
    B -->|Process| C[Consumer]
    C -->|Success| D[Complete]
    C -->|Failure| E{Retry Count &lt; Max?}
    E -->|Yes| B
    E -->|No| F[Dead Letter Queue]
    F -->|Analyze| G[Error Logging]
    F -->|Reprocess| H[Manual Retry]
    H --> B`,
                implementation: `using Azure.Messaging.ServiceBus;

// Configure processor with dead-letter handling
await using var processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions
{
    MaxConcurrentCalls = 1,
    MaxAutoLockRenewalDuration = TimeSpan.FromMinutes(5)
});

processor.ProcessMessageAsync += async args =>
{
    try
    {
        // Process message
        var body = args.Message.Body.ToString();
        await ProcessOrderAsync(body);
        await args.CompleteMessageAsync(args.Message);
    }
    catch (Exception ex)
    {
        // Check delivery count
        if (args.Message.DeliveryCount >= 3)
        {
            // Dead-letter the message
            await args.DeadLetterMessageAsync(args.Message,
                deadLetterReason: "MaxDeliveryCountExceeded",
                deadLetterErrorDescription: ex.Message);
        }
        else
        {
            // Abandon for retry
            await args.AbandonMessageAsync(args.Message);
        }
    }
};

processor.ProcessErrorAsync += args =>
{
    Console.WriteLine($"Error: {args.Exception.Message}");
    return Task.CompletedTask;
};

// Process dead-letter queue
var dlqPath = EntityNameFormatter.FormatDeadLetterPath(queueName);
await using var dlqProcessor = client.CreateProcessor(dlqPath);

dlqProcessor.ProcessMessageAsync += async args =>
{
    // Analyze failed message
    var reason = args.Message.DeadLetterReason;
    var description = args.Message.DeadLetterErrorDescription;

    // Log for analysis
    LogDeadLetterMessage(args.Message, reason, description);

    // Optionally reprocess or archive
    await args.CompleteMessageAsync(args.Message);
};

dlqProcessor.ProcessErrorAsync += args =>
{
    Console.WriteLine(args.Exception.Message);
    return Task.CompletedTask;
};

await dlqProcessor.StartProcessingAsync();`,
                approaches: [
                    "Set MaxDeliveryCount to limit retry attempts before dead-lettering",
                    "Manually dead-letter messages for business logic failures",
                    "Use separate processor for dead-letter queue analysis",
                    "Implement alerting when DLQ message count exceeds threshold",
                    "Create scheduled job to analyze and reprocess DLQ messages",
                    "Archive DLQ messages after analysis for audit purposes",
                    "Use DLQ message properties to categorize failure types"
                ]
            },
            {
                number: 4,
                title: "What are Service Bus Sessions and when should you use them?",
                description: "Service Bus Sessions enable ordered message processing by grouping related messages together. Messages with the same SessionId are processed sequentially by a single consumer, ensuring FIFO ordering and related message grouping. Sessions are essential for scenarios requiring message ordering or grouping.",
                why: "Sessions are crucial when message order matters or when related messages must be processed together. Without sessions, messages can be processed out of order by different consumers, causing data inconsistency or business logic errors.",
                what: "Sessions group messages by SessionId. All messages with the same SessionId are delivered to the same consumer and processed sequentially, maintaining order and enabling related message grouping.",
                how: "Set SessionId when sending messages. Use SessionReceiver to accept sessions. Process messages within a session sequentially. Release the session when done to allow processing of other sessions.",
                pros: [
                    "Guarantees message ordering within a session",
                    "Groups related messages together",
                    "Enables stateful message processing",
                    "Prevents race conditions",
                    "Supports complex workflows",
                    "Enables transaction-like behavior"
                ],
                cons: [
                    "Reduces parallelism (one session at a time per receiver)",
                    "Can cause blocking if session processing is slow",
                    "More complex implementation",
                    "Requires session management",
                    "Potential for session starvation",
                    "Higher latency for unrelated messages"
                ],
                diagram: `flowchart TD
    A[Message 1<br/>Session: A] --> B[Session Receiver]
    C[Message 2<br/>Session: A] --> B
    D[Message 3<br/>Session: B] --> E[Session Receiver]
    B -->|Process Sequentially| F[Consumer 1]
    E -->|Process Sequentially| G[Consumer 2]
    H[Message 4<br/>Session: A] --> B`,
                implementation: `using Azure.Messaging.ServiceBus;

// Send messages with session ID
await using var sender = client.CreateSender(queueName);

var sessionId = "order-12345";

// Send related messages with same session ID
await sender.SendMessageAsync(new ServiceBusMessage("Order Created")
{
    SessionId = sessionId,
    MessageId = "msg-1"
});

await sender.SendMessageAsync(new ServiceBusMessage("Payment Processed")
{
    SessionId = sessionId,
    MessageId = "msg-2"
});

await sender.SendMessageAsync(new ServiceBusMessage("Order Shipped")
{
    SessionId = sessionId,
    MessageId = "msg-3"
});

// Receive and process session messages
await using var sessionReceiver = await client.AcceptNextSessionAsync(queueName, new ServiceBusSessionReceiverOptions
{
    ReceiveMode = ServiceBusReceiveMode.PeekLock
});

try
{
    // Process all messages in this session sequentially
    while (true)
    {
        var message = await sessionReceiver.ReceiveMessageAsync(TimeSpan.FromSeconds(5));
        if (message == null) break;

        // Process message
        await ProcessOrderMessageAsync(message);
        await sessionReceiver.CompleteMessageAsync(message);
    }
}
finally
{
    await sessionReceiver.CloseAsync();
}

// Using session processor
await using var sessionProcessor = client.CreateSessionProcessor(queueName, new ServiceBusSessionProcessorOptions
{
    MaxConcurrentSessions = 4,
    MaxConcurrentCallsPerSession = 1
});

sessionProcessor.ProcessMessageAsync += async args =>
{
    // Messages in same session processed sequentially
    await ProcessMessageAsync(args.Message);
    await args.CompleteMessageAsync(args.Message);
};

sessionProcessor.ProcessSessionInitializedAsync += args =>
{
    Console.WriteLine($"Session {args.SessionId} started");
    return Task.CompletedTask;
};

sessionProcessor.ProcessSessionClosedAsync += args =>
{
    Console.WriteLine($"Session {args.SessionId} closed");
    return Task.CompletedTask;
};

await sessionProcessor.StartProcessingAsync();`,
                approaches: [
                    "Use sessions for order-dependent message processing",
                    "Group related messages by business entity ID (order ID, user ID)",
                    "Use MaxConcurrentSessions to control parallelism",
                    "Set MaxConcurrentCallsPerSession to 1 for strict ordering",
                    "Implement session timeout handling",
                    "Use session state for maintaining context across messages",
                    "Monitor session lock renewal to prevent expiration"
                ]
            },
            {
                number: 5,
                title: "How do you implement message batching in Azure Service Bus?",
                description: "Message batching allows sending or receiving multiple messages in a single operation, reducing network round trips and improving throughput. Service Bus supports batching up to 100 messages or 256 KB per batch. Batching is essential for high-throughput scenarios.",
                why: "Batching significantly improves performance by reducing network overhead, API calls, and transaction costs. It's crucial for high-volume scenarios where individual message operations would be too slow or expensive.",
                what: "Batching groups multiple messages into a single send or receive operation. Send batching combines multiple messages in one API call. Receive batching retrieves multiple messages in one operation.",
                how: "Use SendMessagesAsync with a list of messages for sending batches. Use ReceiveMessagesAsync with maxMessageCount for receiving batches. Configure PrefetchCount for automatic batching during receive operations.",
                pros: [
                    "Significantly improved throughput",
                    "Reduced network round trips",
                    "Lower API call costs",
                    "Better resource utilization",
                    "Reduced latency per message",
                    "Efficient for high-volume scenarios"
                ],
                cons: [
                    "Batch size limitations (100 messages or 256 KB)",
                    "All-or-nothing failure semantics",
                    "More complex error handling",
                    "Potential for increased latency if waiting for batch",
                    "Requires careful batch size tuning",
                    "Memory overhead for large batches"
                ],
                diagram: `flowchart TD
    A[Message 1] --> E[Batch]
    B[Message 2] --> E
    C[Message 3] --> E
    D[Message 4] --> E
    E -->|Single API Call| F[Service Bus]
    F -->|Batch Receive| G[Consumer]
    G --> H[Process Batch]`,
                implementation: `using Azure.Messaging.ServiceBus;
using System.Collections.Generic;
using System.Linq;

// Send batch of messages
await using var sender = client.CreateSender(queueName);

var messages = new List<ServiceBusMessage>();
for (int i = 0; i < 100; i++)
{
    messages.Add(new ServiceBusMessage($"Message {i}")
    {
        MessageId = Guid.NewGuid().ToString()
    });
}

// Send as batch (up to 100 messages or 256 KB)
await sender.SendMessagesAsync(messages);

// Receive batch of messages
await using var receiver = client.CreateReceiver(queueName, new ServiceBusReceiverOptions
{
    ReceiveMode = ServiceBusReceiveMode.PeekLock,
    PrefetchCount = 10 // Prefetch messages for batching
});

// Receive multiple messages at once
var receivedMessages = await receiver.ReceiveMessagesAsync(
    maxMessages: 10,
    maxWaitTime: TimeSpan.FromSeconds(5)
);

foreach (var message in receivedMessages)
{
    // Process message
    await ProcessMessageAsync(message);
    await receiver.CompleteMessageAsync(message);
}

// Manual batch creation with size limits
async Task SendBatchAsync(ServiceBusSender batchSender, List<ServiceBusMessage> msgs)
{
    const int maxBatchCount = 100;
    const int maxBatchSizeBytes = 256 * 1024; // 256 KB

    var currentBatch = new List<ServiceBusMessage>();
    int currentSize = 0;

    foreach (var msg in msgs)
    {
        var messageSize = msg.Body.ToMemory().Length;

        if (currentBatch.Count >= maxBatchCount ||
            currentSize + messageSize > maxBatchSizeBytes)
        {
            await batchSender.SendMessagesAsync(currentBatch);
            currentBatch.Clear();
            currentSize = 0;
        }

        currentBatch.Add(msg);
        currentSize += messageSize;
    }

    if (currentBatch.Any())
    {
        await batchSender.SendMessagesAsync(currentBatch);
    }
}`,
                approaches: [
                    "Use SendMessagesAsync for sending multiple messages in one call",
                    "Set PrefetchCount for automatic receive batching",
                    "Use ReceiveMessagesAsync with maxMessageCount for manual batching",
                    "Implement batch size monitoring to optimize throughput",
                    "Handle batch failures with retry logic",
                    "Use batching for bulk operations and high-volume scenarios",
                    "Balance batch size with latency requirements"
                ]
            },
            {
                number: 6,
                title: "How do you implement duplicate detection in Service Bus?",
                description: "Duplicate detection prevents processing the same message multiple times by tracking MessageId within a time window. Service Bus automatically detects and rejects duplicate messages based on MessageId and DuplicateDetectionHistoryTimeWindow.",
                why: "Duplicate detection is essential for idempotency and preventing duplicate processing, which can cause data corruption, incorrect business logic execution, or financial errors.",
                what: "Duplicate detection uses MessageId to identify duplicates within a configurable time window (up to 7 days). Messages with duplicate MessageId within the window are automatically rejected.",
                how: "Enable duplicate detection on queue/topic creation. Set DuplicateDetectionHistoryTimeWindow. Always set unique MessageId when sending messages.",
                pros: [
                    "Prevents duplicate processing",
                    "Ensures idempotency",
                    "Protects against retry duplicates",
                    "Automatic detection",
                    "Configurable time window",
                    "No application code needed for basic detection"
                ],
                cons: [
                    "Requires unique MessageId generation",
                    "Time window limitation (7 days max)",
                    "Storage overhead for tracking",
                    "Potential false positives if IDs reused",
                    "Cannot detect duplicates across different entities",
                    "Does not replace idempotent handler logic"
                ],
                diagram: `flowchart TD
    A[Message with ID: 123] --> B{Duplicate Detection}
    B -->|New| C[Accept]
    D[Message with ID: 123] --> B
    B -->|Duplicate| E[Drop / Ignore]`,
                implementation: `using Azure.Messaging.ServiceBus.Administration;
using Azure.Messaging.ServiceBus;

// Enable duplicate detection when creating queue
var adminClient = new ServiceBusAdministrationClient(connectionString);

var queueOptions = new CreateQueueOptions("orders-queue")
{
    DuplicateDetectionHistoryTimeWindow = TimeSpan.FromMinutes(10),
    RequiresDuplicateDetection = true
};

if (!await adminClient.QueueExistsAsync("orders-queue"))
{
    await adminClient.CreateQueueAsync(queueOptions);
}

// Send message with unique MessageId
await using var sender = client.CreateSender("orders-queue");
var orderId = 12345;
var timestamp = DateTime.UtcNow.Ticks;

var message = new ServiceBusMessage("Order data")
{
    MessageId = $"order-{orderId}-{timestamp}" // Unique ID
};

await sender.SendMessageAsync(message);

// Sending the same messageId again within the detection window will be ignored by Service Bus`,
                approaches: [
                    "Use business entity ID + timestamp for MessageId",
                    "Enable duplicate detection on entity creation",
                    "Set appropriate time window based on business needs",
                    "Still implement idempotent message processing logic in consumers",
                    "Monitor metrics for duplicate detection hits",
                    "Avoid reusing MessageId values within the window"
                ]
            },
            {
                number: 7,
                title: "Explain Service Bus message locking and lock renewal",
                description: "Service Bus uses peek-lock pattern where messages are locked when received, preventing other consumers from processing them. Lock duration is configurable (default 60 seconds). Lock renewal extends the lock duration for long-running operations.",
                why: "Understanding locking is crucial for reliable message processing. Without proper lock management, messages can be reprocessed or lost, causing duplicate processing or message loss.",
                what: "Peek-lock mode locks messages for a duration (LockDuration). Messages must be completed or abandoned before lock expires. Lock renewal extends the lock duration for long-running operations.",
                how: "Set LockDuration on queue/subscription. Use PeekLock receive mode. Call RenewMessageLockAsync to extend lock (for receiver APIs). With processors, use MaxAutoLockRenewalDuration for automatic renewal.",
                pros: [
                    "Prevents duplicate processing while lock is held",
                    "Enables reliable message handling",
                    "Supports long-running operations",
                    "Automatic lock renewal available with processors",
                    "Configurable lock duration",
                    "Prevents message loss when used correctly"
                ],
                cons: [
                    "Requires proper lock management",
                    "Lock expiration can cause reprocessing",
                    "Lock renewal adds overhead",
                    "Potential for lock contention",
                    "Need to handle lock timeouts",
                    "Complexity in distributed scenarios"
                ],
                diagram: `flowchart TD
    A[Receive Message] --> B[Lock Acquired<br/>e.g. 60 seconds]
    B --> C{Processing}
    C -->|Long Running| D[Renew Lock]
    D --> C
    C -->|Complete| E[Release Lock]
    C -->|Timeout| F[Lock Expired<br/>Message Visible Again]`,
                implementation: `using Azure.Messaging.ServiceBus;
using System.Threading;

// Configure lock duration when creating queue (admin API)
var adminClient = new ServiceBusAdministrationClient(connectionString);
var createOptions = new CreateQueueOptions(queueName)
{
    LockDuration = TimeSpan.FromMinutes(5) // 5 minute lock
};
// Call adminClient.CreateQueueAsync(createOptions) if queue doesn't exist

// Receive with peek-lock
await using var receiver = client.CreateReceiver(queueName, new ServiceBusReceiverOptions
{
    ReceiveMode = ServiceBusReceiveMode.PeekLock
});

var msg = await receiver.ReceiveMessageAsync(TimeSpan.FromSeconds(10));
if (msg != null)
{
    // Manual lock renewal for long operations
    using var cts = new CancellationTokenSource();
    var renewalTask = Task.Run(async () =>
    {
        while (!cts.Token.IsCancellationRequested)
        {
            try
            {
                await Task.Delay(TimeSpan.FromSeconds(30), cts.Token);
                await receiver.RenewMessageLockAsync(msg, cts.Token);
                Console.WriteLine("Lock renewed");
            }
            catch (TaskCanceledException) { }
            catch (Exception ex)
            {
                Console.WriteLine($"Lock renewal failed: {ex.Message}");
                break;
            }
        }
    }, cts.Token);

    try
    {
        // Long-running processing
        await ProcessLongRunningAsync(msg);
        await receiver.CompleteMessageAsync(msg);
    }
    catch
    {
        await receiver.AbandonMessageAsync(msg);
        throw;
    }
    finally
    {
        cts.Cancel();
        await renewalTask;
    }
}

// Automatic lock renewal with processor
await using var processor = client.CreateProcessor(queueName, new ServiceBusProcessorOptions
{
    MaxConcurrentCalls = 5,
    AutoCompleteMessages = false,
    MaxAutoLockRenewalDuration = TimeSpan.FromMinutes(10)
});

processor.ProcessMessageAsync += async args =>
{
    // Lock will be auto-renewed for up to MaxAutoLockRenewalDuration
    await ProcessLongRunningAsync(args.Message);
    await args.CompleteMessageAsync(args.Message);
};

processor.ProcessErrorAsync += args =>
{
    Console.WriteLine($"Processor error: {args.Exception.Message}");
    return Task.CompletedTask;
};

await processor.StartProcessingAsync();`,
                approaches: [
                    "Set appropriate LockDuration based on typical processing time",
                    "Use MaxAutoLockRenewalDuration for automatic renewal with processors",
                    "Use manual RenewMessageLockAsync for receiver-based long-running operations",
                    "Monitor lock-lost exceptions and handle gracefully",
                    "Design handlers to be as fast as possible; offload very long work to background jobs",
                    "Use shorter locks with renewal instead of a single very long lock for better resiliency"
                ]
            }
        ];

        // Generate Table of Contents
        const tocList = document.getElementById('tocList');
        questions.forEach(q => {
            const link = document.createElement('a');
            link.href = `#question-${q.number}`;
            link.textContent = `Q${q.number}: ${q.title.substring(0, 40)}...`;
            link.addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById(`question-${q.number}`).scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
            tocList.appendChild(link);
        });

        // Generate Questions
        const container = document.getElementById('questionsContainer');
        questions.forEach(q => {
            const card = document.createElement('div');
            card.className = 'question-card';
            card.id = `question-${q.number}`;

            card.innerHTML = `
                <div class="question-number">Question ${q.number} of 50</div>
                <h2 class="question-title">${q.title}</h2>

                <div class="question-section">
                    <h3>1. Detailed Description</h3>
                    <p>${q.description}</p>
                </div>

                <div class="question-section">
                    <h3>2. Why / What / How</h3>
                    <p><strong>Why:</strong> ${q.why}</p>
                    <p><strong>What:</strong> ${q.what}</p>
                    <p><strong>How:</strong> ${q.how}</p>
                </div>

                <div class="question-section">
                    <h3>3. Pros and Cons</h3>
                    <div class="pros-cons">
                        <div class="pros-box">
                            <h4>Pros</h4>
                            <ul>
                                ${q.pros.map(p => `<li>${p}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="cons-box">
                            <h4>Cons</h4>
                            <ul>
                                ${q.cons.map(c => `<li>${c}</li>`).join('')}
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="question-section">
                    <h3>4. Design Diagram</h3>
                    <div class="diagram-container">
                        <div class="diagram-title">Architecture Diagram</div>
                        <div class="mermaid">${q.diagram}</div>
                    </div>
                </div>

                <div class="question-section">
                    <h3>5. Implementation (C#)</h3>
                    <div class="code-block">
                        <pre><code>${q.implementation.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>
                    </div>
                </div>

                <div class="question-section">
                    <h3>6. Approaches</h3>
                    <ul>
                        ${q.approaches.map(a => `<li>${a}</li>`).join('')}
                    </ul>
                </div>
            `;

            container.appendChild(card);
        });

        // Initialize Mermaid after DOM is populated
        window.addEventListener('load', () => {
            mermaid.init(undefined, '.mermaid');
        });
    </script>
</body>
</html>
